<!DOCTYPE html>
<html lang="ja">
<head>
<link rel="icon" href="/favicon.ico">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="/icon-512.png">

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CoinRader - 暗号資産ダッシュボード</title>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TDEBXC7DH6"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TDEBXC7DH6');
</script>
 
 <!-- SEO / Canonical -->
<meta name="description" content="CoinRaderは、暗号資産のトレンドTOP5・上昇率TOP5・出来高急増TOP5・時価総額TOP20とMarket Overviewをまとめて確認できるダッシュボードです。データ：CoinGecko。">
<link rel="canonical" href="https://coinrader.net/">

<!-- Open Graph (SNS表示) -->
<meta property="og:site_name" content="CoinRader">
<meta property="og:title" content="CoinRader | 暗号資産ダッシュボード">
<meta property="og:description" content="トレンド/上昇率/出来高/時価総額をひと目で。Market Overviewも搭載。">
<meta property="og:type" content="website">
<meta property="og:url" content="https://coinrader.net/">

<!-- X(Twitter) -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="CoinRader | 暗号資産ダッシュボード">
<meta name="twitter:description" content="トレンド/上昇率/出来高/時価総額をひと目で。">

<style>
  .hero{padding:28px 0 16px;}
  .hero-inner{max-width:1100px;margin:0 auto;padding:0 16px;}
  .hero-copy{padding:18px 16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;
    background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));}
  .hero-badges{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
  .badge{font-size:12px;padding:4px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.04);color:rgba(229,231,235,.9)}
  .hero-title{margin:8px 0 8px;font-size:28px;line-height:1.2;letter-spacing:.2px}
  .hero-sub{margin:0 0 14px;color:rgba(229,231,235,.85);font-size:14px;line-height:1.7}
  .hero-cta{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:6px 0 6px}
  .hero-note{margin:10px 0 0;color:rgba(229,231,235,.55);font-size:12px}

  /* PC/スマホの改行制御 */
  .br-sp{display:none}
  .br-pc{display:inline}

  @media (max-width: 640px){
    .hero{padding:18px 0 10px}
    .hero-title{font-size:22px}
    .hero-cta .btn{width:100%;text-align:center}
    .br-sp{display:inline}
    .br-pc{display:none}
  }
  *{ box-sizing:border-box; }
  body{
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    background:#0f172a; color:#e5e7eb; margin:0; padding:12px;
  }
  h1{ margin:6px 4px 10px; font-size:20px; letter-spacing:.2px; }

  .topbar{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin:0 4px 10px; }
  .pill{ border:1px solid #374151; background:#111827; color:#e5e7eb; border-radius:999px; padding:6px 10px; font-size:12px; }
  .btn{
    padding:8px 12px; border-radius:999px; border:1px solid #374151;
    background:#111827; color:#e5e7eb; cursor:pointer; font-size:12px;
  }
  .btn.primary{ background:#1e88e5; border-color:#1e88e5; color:#fff; }
  .btn:disabled{ opacity:.55; cursor:not-allowed; }

  .nav{ display:flex; gap:8px; flex-wrap:wrap; margin:0 4px 14px; }
  .nav .btn{ padding:6px 12px; font-size:12px; }

  section{ margin:0 4px 18px; }
  .section-header{ display:flex; align-items:flex-end; justify-content:space-between; gap:12px; margin:0 0 10px; }
  .section-title{ font-size:15px; font-weight:700; color:#f9fafb; }
  .section-sub{ font-size:12px; color:#9ca3af; margin-top:3px; }
  .section-actions{ display:flex; gap:8px; align-items:center; }
  .linkbtn{
    display:inline-flex; align-items:center; justify-content:center;
    text-decoration:none; color:#e5e7eb;
    border:1px solid #374151; background:#111827;
    padding:6px 10px; border-radius:999px; font-size:12px;
  }
  .linkbtn:hover{ border-color:#6b7280; }

  .grid{
    display:grid;
    gap:12px;
    align-items:stretch;
    grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
  }

  /* 1200px以上は必ず5列 */
  @media (min-width: 1200px){
    .grid{ grid-template-columns: repeat(5, minmax(0, 1fr)); }
  }

  /* responsive columns (uniform across sections) */
  .card{
    position:relative; background:#111827; border-radius:12px; padding:10px 12px;
    box-shadow:0 6px 18px rgba(0,0,0,0.45); cursor:pointer;
    transition:transform .15s ease, box-shadow .15s ease;
    overflow:hidden;
    min-width:0;
  }
  /* ===== Card height / bottom alignment (index grids) ===== */
  .grid .card{
    display:flex;
    flex-direction:column;
    height:100%;
  }

  /* 上部（ヘッダー/テキスト）は上に寄せたまま */
  .grid .card .card-header{
    flex:0 0 auto;
  }

  /* スパークライン（カード内のcanvas）を常に下端に寄せる */
  .grid .card canvas{
    margin-top:auto !important;
  }

  /* 念のため：余白を統一（カード内の最後が詰まり過ぎないように） */
  .grid .card canvas{
    margin-bottom:2px;
  }

  .card:hover{ transform:translateY(-2px); box-shadow:0 10px 22px rgba(0,0,0,.5); }

  .card.up{ border-left:4px solid #1e88e5; }
  .card.down{ border-left:4px solid #d32f2f; }

  .rank-badge{
    position:absolute; top:8px; left:8px; width:32px; height:20px;
    display:flex; align-items:center; justify-content:center;
    font-size:13px; font-weight:700; border-radius:6px; color:#fff;
    background:#374151; z-index:2;
  }
  .rank-1{ background:#facc15; color:#111827; }
  .rank-2{ background:#9ca3af; color:#111827; }
  .rank-3{ background:#b45309; color:#fff; }

  .card-header{ display:flex; justify-content:space-between; align-items:flex-start; gap:10px; }
  .coin-header{ display:flex; align-items:center; gap:8px; padding-left:36px; min-width:0; }
  .coin-icon{ width:28px; height:28px; border-radius:50%; }
  .coin-name{ font-weight:600; font-size:14px; color:#f9fafb; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:150px; }
  .coin-symbol{ font-size:11px; color:#9ca3af; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .price{ font-size:15px; font-weight:600; color:#f9fafb; text-align:right; }
  .meta{ font-size:11px; color:#9ca3af; text-align:right; margin-top:2px; }
  .change{ font-size:12px; text-align:right; margin-top:2px; }
  .positive{ color:#4ade80; }
  .negative{ color:#f87171; }

  canvas{ display:block; width:100% !important; height:48px !important; margin-top:6px; }

  .msg{ grid-column:1 / -1; padding:10px 8px; color:#9ca3af; }
  .msg.err{ color:#f87171; }

  /* Market Overview */
  .overview{ display:grid; grid-template-columns: 1fr; gap:12px; }
  @media (min-width: 900px){ .overview{ grid-template-columns: 360px 1fr; } }
 
  .overview-card{ background:#111827; border-radius:12px; padding:12px; box-shadow:0 6px 18px rgba(0,0,0,0.45); }
  .overview-note{ font-size:11px; color:#9ca3af; margin-top:8px; }
  .donut-wrap{ width:100%; max-width:340px; aspect-ratio:1/1; margin:0 auto; }
  .donut-wrap canvas{ width:100% !important; height:100% !important; margin-top:0; }
 
  .kpi-grid{ display:grid; grid-template-columns: repeat(1, minmax(0,1fr)); gap:10px; }
  @media (min-width: 560px){ .kpi-grid{ grid-template-columns: repeat(2, minmax(0,1fr)); } }
 
  .kpi{ border:1px solid #1f2937; border-radius:12px; padding:10px 12px; background:#0b1220; }
  .kpi-label{ font-size:11px; color:#9ca3af; }
  .kpi-value{ margin-top:6px; font-size:16px; font-weight:700; color:#f9fafb; }

  .kpi-canvas{ width:100% !important; height:70px !important; margin-top:8px; }
  .kpi-canvas.tall{ height:90px !important; }

  .kpi-sub{ margin-top:6px; font-size:11px; color:#9ca3af; line-height:1.35; }

  .kpi-legend{ margin-top:6px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:11px; color:#9ca3af; }
  .kpi-legend .item{ display:inline-flex; align-items:center; gap:6px; }
  .kpi-legend .dot{ width:8px; height:8px; border-radius:999px; display:inline-block; }
  .kpi-legend .dot.up{ background:rgba(30,136,229,0.9); }
  .kpi-legend .dot.down{ background:rgba(211,47,47,0.9); }

  .barline{ margin-top:8px; height:10px; width:100%; border-radius:999px; overflow:hidden; background:#0f172a; border:1px solid #1f2937; display:flex; }
  .bar-up{ background:rgba(30,136,229,0.75); height:100%; }
  .bar-down{ background:rgba(211,47,47,0.75); height:100%; }
  .bar-flat{ background:rgba(156,163,175,0.55); height:100%; }

  .centerbar{ margin-top:8px; height:10px; width:100%; border-radius:999px; overflow:hidden; background:#0f172a; border:1px solid #1f2937; position:relative; }
  .centerline{ position:absolute; left:50%; top:0; width:1px; height:100%; background:#334155; }
  .centerfill{ position:absolute; top:0; height:100%; border-radius:999px; }
  .centerfill.pos{ background:rgba(30,136,229,0.75); }
  .centerfill.neg{ background:rgba(211,47,47,0.75); }

  .stackbar{ margin-top:8px; height:10px; width:100%; border-radius:999px; overflow:hidden; background:#0f172a; border:1px solid #1f2937; display:flex; }
  .seg{ height:100%; }
  .seg.btc{ background:rgba(250,204,21,0.85); }
  .seg.eth{ background:rgba(96,165,250,0.85); }
  .seg.stable{ background:rgba(52,211,153,0.85); }
  .seg.other{ background:rgba(156,163,175,0.55); }
  /* Footer */
  .site-footer{
    margin-top: 28px;
    padding: 18px 14px;
    border-top: 1px solid rgba(255,255,255,0.08);
    color: rgba(229,231,235,0.85);
  }
  .footer-inner{ max-width: 1200px; margin: 0 auto; }
  .footer-note{ font-size: 12px; line-height: 1.6; opacity: 0.95; }
  .footer-links{
    display: flex; flex-wrap: wrap; gap: 10px 14px;
    margin-top: 10px;
  }
  .footer-links a{
    font-size: 12px;
    color: rgba(229,231,235,0.9);
    text-decoration: underline;
    text-underline-offset: 2px;
  }
  .footer-copy{ margin-top: 10px; font-size: 12px; opacity: 0.75; }
  .brand { margin: 0 4px 6px; }
  .brandLink { display: inline-block; }
  .brandLogo{
    height: 28px;
    width: auto;
    display: block;
  }
  .btn-cta{
    display:inline-flex; align-items:center; justify-content:center;
    padding:9px 14px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.18);
    background:rgba(255,255,255,.06);
    color:#e5e7eb;
    text-decoration:none;
    font-weight:700;
  }
  .btn-cta:hover{ background:rgba(255,255,255,.10); }
  /* ===== CTA (収益導線) ===== */
  .cta-block{
    margin: 0 4px 18px;
    padding: 12px 12px;
    border: 1px solid rgba(255,255,255,.10);
    border-radius: 12px;
    background: rgba(255,255,255,.04);
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
  }
  .cta-inner{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    flex-wrap:wrap;
  }
  .cta-title{ font-weight:800; font-size:14px; color:#f9fafb; }
  .cta-sub{ margin-top:4px; font-size:12px; color:#9ca3af; }
  .cta-actions{ display:flex; gap:8px; flex-wrap:wrap; }
  .cta-note{ margin-top:8px; font-size:11px; color:rgba(229,231,235,.70); }

  .brand{
    max-width:1100px;
    margin:0 auto 6px;
    padding:0 16px;
  }

  /* sparkline (Chart.js) */
  .sparkline{width:100% !important; height:64px !important; display:block; margin-top:10px;}
  .card canvas.sparkline{max-width:100%;}

</style>
</head>
<body>
<div class="brand">
  <a href="/" class="brandLink">
    <img class="brandLogo" src="assets/coinrader_logo_horizontal_075_dark.png" alt="CoinRader">
  </a>
</div>
  <section class="hero">
    <div class="hero-inner">
      <div class="hero-copy">
        <div class="hero-badges">
          <span class="badge">毎日3分</span>
          <span class="badge">相場の温度感</span>
          <span class="badge">トレンド把握</span>
        </div>

        <h1 class="hero-title">
          暗号資産の“いま”を<br class="br-sp">一画面で把握
        </h1>

        <p class="hero-sub">
          時価総額・トレンド・急騰急落をまとめて表示。<br class="br-pc">
          迷わず「今日の注目」からチェックできます。
        </p>

        <div class="hero-cta">
          <a class="btn primary"
             href="#sec-trend"
             data-cta="hero_trend"
             aria-label="トレンドTOP5へ"
             onclick="event.preventDefault(); scrollToId('sec-trend');">
            今日の注目を見る
          </a>

          <a class="btn"
             href="#sec-mcap"
             data-cta="hero_mcap"
             aria-label="時価総額TOP20へ"
             onclick="event.preventDefault(); scrollToId('sec-mcap');">
            主要コインTOPへ
          </a>

        </div>

        <p class="hero-note">
          ※価格・ランキングは取得元APIの反映タイミングにより遅延する場合があります。
        </p>
      </div>
    </div>
  </section>
<div class="topbar">
    <a class="btn-cta" href="start.html" data-ga="cta_start_header">始め方</a>

  <div class="pill" id="statusPill">状態: 初期化中…</div>
  <div class="pill" id="updatedPill">更新: --</div>
  <button class="btn" id="refreshBtn" onclick="refreshData()">更新</button>
</div>

<div class="nav">
  <button class="btn" onclick="scrollToId('sec-trend')">トレンド</button>
  <button class="btn" onclick="scrollToId('sec-gainers')">上昇率</button>
  <button class="btn" onclick="scrollToId('sec-volume')">出来高</button>
  <button class="btn" onclick="scrollToId('sec-mcap')">時価総額</button>
  <button class="btn" onclick="scrollToId('sec-overview')">概況</button>
</div>
<section class="cta-block" aria-label="おすすめ取引所導線">
  <div class="cta-inner">
    <div class="cta-text">
      <div class="cta-title">取引所おすすめ（広告・PR）</div>
      <div class="cta-sub">国内取引所を用途別に比較。公式サイト/キャンペーン導線をまとめています。</div>
    </div>
    <div class="cta-actions">
      <a class="btn primary" href="./ads-pr.html" data-cta="top_to_adspr">取引所おすすめを見る</a>
      <a class="btn" href="./start.html" data-cta="top_to_start">始め方</a>
    </div>
  </div>
  <div class="cta-note">※当サイトは一部リンクにアフィリエイト広告を含みます。</div>
</section>

<section id="sec-trend">
  <div class="section-header">
    <div>
      <div class="section-title">トレンド TOP5</div>
      <div class="section-sub">CoinGeckoの「トップトレンド」（API: /search/trending）／カード内チャート：過去7日スパークライン（サンプル間隔・点数はAPI依存）</div>
    </div>
    <div class="section-actions">
      <a class="linkbtn" href="https://www.coingecko.com/ja/highlights/trending-crypto" target="_blank" rel="noopener">もっと見る</a>
    </div>
  </div>
  <div class="grid" id="grid-trend"><div class="msg">データ取得中…</div></div>
</section>

<section id="sec-gainers">
  <div class="section-header">
    <div>
      <div class="section-title">上昇率 TOP5</div>
      <div class="section-sub">24h騰落率TOP5（時価総額上位250銘柄から抽出）／カード内チャート：過去24時間（1d）（サンプル間隔・点数はAPI依存）</div>
    </div>
    <div class="section-actions">
      <a class="linkbtn" href="https://www.coingecko.com/ja/crypto-gainers-losers" target="_blank" rel="noopener">もっと見る</a>
    </div>
  </div>
  <div class="grid" id="grid-gainers"><div class="msg">データ取得中…</div></div>
</section>

<section id="sec-volume">
  <div class="section-header">
    <div>
      <div class="section-title">出来高 TOP5</div>
      <div class="section-sub">24h出来高TOP5（時価総額上位250銘柄から抽出）／カード内チャート：過去24時間（1d）（サンプル間隔・点数はAPI依存）</div>
    </div>
    <div class="section-actions">
      <a class="linkbtn" href="https://www.coingecko.com/ja/highlights/high-volume" target="_blank" rel="noopener">もっと見る</a>
    </div>
  </div>
  <div class="grid" id="grid-volume"><div class="msg">データ取得中…</div></div>
</section>

<section id="sec-mcap">
  <div class="section-header">
    <div>
      <div class="section-title">時価総額 TOP20</div>
      <div class="section-sub">時価総額上位20（JPY）／カード内チャート：過去7日スパークライン（サンプル間隔・点数はAPI依存）</div>
    </div>
    <div class="section-actions">
      <a class="linkbtn" href="https://www.coingecko.com/ja" target="_blank" rel="noopener">もっと見る</a>
    </div>
  </div>
  <div class="grid" id="grid-mcap"><div class="msg">データ取得中…</div></div>
</section>

<section id="sec-overview">
  <div class="section-header">
    <div>
      <div class="section-title">Market Overview</div>
      <div class="section-sub">※追加APIなし：時価総額上位250（JPY）から算出した概況</div>
    </div>
    <div class="section-actions">
      <a class="linkbtn" href="https://www.coingecko.com" target="_blank" rel="noopener">もっと見る</a>
    </div>
  </div>

  <div class="overview" id="overviewWrap">
    <div class="overview-card">
      <div class="donut-wrap"><canvas id="domChart"></canvas></div>
      <div class="overview-note">BTC / ETH / ステーブル / Others の時価総額構成比（対象: 上位250の合計）</div>
    </div>

    <div class="overview-card">
      <div class="kpi-grid">
        <div class="kpi">
          <div class="kpi-label">上昇 / 下落（7d推移 / 上位250）</div>
          <div class="kpi-value" id="kpiBreadth">-</div>
          <div class="kpi-legend" aria-hidden="true"><span class="item"><span class="dot up"></span>青＝上昇数</span><span class="item"><span class="dot down"></span>赤＝下落数</span></div>
          <div class="kpi-sub" id="kpiBreadthSub">上位250を対象に、7日前を基準にした累積リターンで「上昇/下落/横ばい」を判定し、日次の推移を表示（青＝上昇、赤＝下落、灰＝横ばい）。軸は見やすさのため非表示です。</div>
          <canvas class="kpi-canvas tall" id="breadthLine"></canvas>
        </div>
        <div class="kpi">
          <div class="kpi-label">平均リターン（7d推移 / 上位250）</div>
          <div class="kpi-value" id="kpiAvgChange">-</div>
          <div class="kpi-sub" id="kpiAvgSub">上位250の各銘柄について、7日前の価格を基準(0%)として現在までの累積リターンを算出し、その平均を表示します。0より上は平均的に上昇、下は下落。</div>
          <canvas class="kpi-canvas" id="avgLine"></canvas>
        </div>
        <div class="kpi">
          <div class="kpi-label">上位250 時価総額合計（推定7d推移 / JPY）</div>
          <div class="kpi-value" id="kpiTotalMcap">-</div>
          <div class="kpi-sub">推定: 各銘柄の現在の時価総額×(各時点価格/現在価格) を合算（供給一定の近似）。</div>
          <canvas class="kpi-canvas" id="mcapLine"></canvas>
        </div>
        <div class="kpi">
          <div class="kpi-label">上位250 出来高合計（推定7d推移 / JPY）</div>
          <div class="kpi-value" id="kpiTotalVol">-</div>
          <div class="kpi-sub">注意: 出来高の履歴は /coins/markets では取れないため、現在出来高×(価格比) の簡易推定（目安）。正確な出来高の推移には別データソースが必要です。</div>
          <canvas class="kpi-canvas" id="volLine"></canvas>
        </div>
      </div>
      <div class="overview-note">※推移グラフは追加APIなしで作るため、上位250の「7日スパークライン」等から概算しています（目安）。</div>
    </div>
  </div>

  <div class="msg" id="overviewMsg" style="display:none"></div>
</section>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  if (typeof Chart !== "undefined" && Chart.registerables) { Chart.register.apply(null, Chart.registerables); }

  // ============ CoinGecko API Key（運営者用）===========
  // 公開サイトでは入力欄を出さない方がUXが良いため、キーはここに固定してください。
  // 例: const COINGECKO_API_KEY = 'CG-xxxxxxxxxxxxxxxx';
  // ※このHTMLは閲覧者にも見えるため、将来的にはWorkersプロキシでキーを隠すのが推奨です。
  const COINGECKO_API_KEY = '';

  // ============ Refresh / Rate-limit friendly ============
  const REFRESH_COOLDOWN_MS = 60 * 1000; // 60s
  let lastRefreshAt = 0;
  let refreshTimer = null;
  const refreshBtn = document.getElementById('refreshBtn');

  function setStatus(text){ document.getElementById('statusPill').textContent = '状態: ' + text; }

  // --- Updated time pill (stay on page -> time keeps moving) ---
  function formatAgo(ts){
    if(!ts) return '';
    const d = Date.now() - ts;
    if (d < 10 * 1000) return 'たった今';
    if (d < 60 * 1000) return `${Math.floor(d/1000)}秒前`;
    if (d < 60 * 60 * 1000) return `${Math.floor(d/60000)}分前`;
    if (d < 24 * 60 * 60 * 1000) return `${Math.floor(d/3600000)}時間前`;
    return `${Math.floor(d/86400000)}日前`;
  }

  function renderUpdatedPill(){
    const el = document.getElementById('updatedPill');
    if(!el) return;
    const ts = getLastFetchAt();
    if(!ts){
      el.textContent = '更新: --';
      return;
    }
    const dt = new Date(ts);
    const ago = formatAgo(ts);
    el.textContent = '更新: ' + dt.toLocaleString('ja-JP', { hour12:false }) + (ago ? `（${ago}）` : '');
  }

  function setUpdated(){
    // 互換用：今後は localStorage(lastFetch) を基準に表示する
    renderUpdatedPill();
  }

  function startUpdatedTicker(){
    renderUpdatedPill();
    setInterval(renderUpdatedPill, 1000);
  }

  
  // --- Auto refresh (every 3 min when tab is visible) ---
  const AUTO_REFRESH_MS = 3 * 60 * 1000;
  function startAutoRefresh(){
    setInterval(() => {
      try{
        if (document.visibilityState !== 'visible') return;
        // 3分ごとに更新。refreshData側で60sクールダウンも効く
        refreshData();
      }catch(e){}
    }, AUTO_REFRESH_MS);
  }

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

// ============ Local cache (F5連打対策) ============
const CACHE_TTL_MS = 5 * 60 * 1000;            // 5分はキャッシュを優先表示
const BOOT_NETWORK_COOLDOWN_MS = 25 * 1000;    // 25秒以内の再読み込みはネット取得をスキップ（API制限対策）
const LS_KEYS = {
  markets: "cg_marketsTop250_jpy_v1",
  trendingIds: "cg_trendingTop5_ids_v1",
  trendingSnapshot: "cg_trendingTop5_snapshot_v1",
  gainersSnapshot: "cg_gainersTop5_snapshot_v1",
  volumeSnapshot: "cg_volumeTop5_snapshot_v1",
  mcapSnapshot: "cg_mcapTop20_snapshot_v1",
  lastFetch: "cg_last_fetch_at_v1"
};

function lsGet(key){
  try { return localStorage.getItem(key); } catch { return null; }
}
function lsSet(key, val){
  try { localStorage.setItem(key, val); } catch {}
}
function readCache(key){
  const raw = lsGet(key);
  if (!raw) return null;
  try { return JSON.parse(raw); } catch { return null; }
}
function writeCache(key, data){
  lsSet(key, JSON.stringify({ ts: Date.now(), data }));
}
function getLastFetchAt(){
  const v = Number(lsGet(LS_KEYS.lastFetch) || "0");
  return Number.isFinite(v) ? v : 0;
}
function setLastFetchAt(){
  lsSet(LS_KEYS.lastFetch, String(Date.now()));
  try{ renderUpdatedPill(); }catch(e){}
}


function coinSnapshot(c){
  if(!c) return null;
  const sp = c.sparkline_in_7d && Array.isArray(c.sparkline_in_7d.price) ? c.sparkline_in_7d.price : null;
  const spTrim = sp ? sp.filter(v => typeof v === 'number' && Number.isFinite(v)).slice(-240) : null;
  return {
    id: c.id,
    name: c.name,
    symbol: c.symbol,
    image: c.image,
    market_cap_rank: c.market_cap_rank ?? null,
    current_price: (typeof c.current_price === 'number' && Number.isFinite(c.current_price)) ? c.current_price : null,
    market_cap: (typeof c.market_cap === 'number' && Number.isFinite(c.market_cap)) ? c.market_cap : null,
    total_volume: (typeof c.total_volume === 'number' && Number.isFinite(c.total_volume)) ? c.total_volume : null,
    price_change_percentage_24h: (typeof c.price_change_percentage_24h === 'number' && Number.isFinite(c.price_change_percentage_24h)) ? c.price_change_percentage_24h : null,
    sparkline_in_7d: spTrim ? { price: spTrim } : undefined,
  };
}

function writeSnapshot(key, coins){
  try{
    const snap = (coins || []).slice(0,5).map(coinSnapshot).filter(Boolean);
    writeCache(key, snap);
  }catch(e){}
}

function readSnapshot(key){
  const cached = readCache(key);
  const snap = (cached && Array.isArray(cached.data)) ? cached.data : null;
  return Array.isArray(snap) ? snap : [];
}


  function tickRefreshButton(){
    const now = Date.now();
    const remain = Math.max(0, (lastRefreshAt + REFRESH_COOLDOWN_MS) - now);
    if (remain > 0){
      refreshBtn.disabled = true;
      refreshBtn.textContent = `更新（${Math.ceil(remain/1000)}s）`;
    } else {
      refreshBtn.disabled = false;
      refreshBtn.textContent = '更新';
    }
  }

  function markRefreshed(){
    lastRefreshAt = Date.now();
    if (refreshTimer) clearInterval(refreshTimer);
    refreshTimer = setInterval(tickRefreshButton, 250);
    tickRefreshButton();
  }

  async function refreshData(){
    const now = Date.now();
    if (now < lastRefreshAt + REFRESH_COOLDOWN_MS){
      tickRefreshButton();
      setStatus('更新まで少しお待ちください');
      return;
    }
    await init(true);
  }

  function scrollToId(id){
    const el = document.getElementById(id);
    if (el) el.scrollIntoView({ behavior:'smooth', block:'start' });
  }

  // ============ Fetch helpers ============
  async function cgFetch(url, options = {}){
    const headers = { ...(options.headers || {}) };
    if (COINGECKO_API_KEY) headers['x-cg-demo-api-key'] = COINGECKO_API_KEY;
    return fetch(url, { ...options, headers });
  }

  async function fetchWithTimeout(url, timeoutMs = 15000, options = {}){
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try{
      return await cgFetch(url, { ...options, signal: controller.signal });
    } finally {
      clearTimeout(timer);
    }
  }

  // 429/5xx を少しだけリトライ（Retry-After対応）
  async function fetchJsonRetry(url, {timeoutMs=15000, retries=2} = {}){
    let lastErr = null;
    for (let attempt=0; attempt<=retries; attempt++){
      try{
        const res = await fetchWithTimeout(url, timeoutMs);
        if (res.ok) return await res.json();

        let bodyText = '';
        try{ bodyText = await res.text(); }catch(e){}
        console.warn('API not ok:', res.status, url, bodyText.slice(0,200));

        if (res.status === 429 || (res.status >= 500 && res.status <= 599)){
          // Retry-After があれば尊重
          if (attempt < retries){
            const ra = res.headers.get('retry-after');
            const waitMs = ra ? (parseInt(ra,10) * 1000) : (600 * (attempt+1));
            await sleep(Math.min(waitMs, 5000));
            continue;
          }
        }

        throw new Error(`HTTP ${res.status}`);

      } catch(e){
        lastErr = e;
        if (attempt < retries){
          await sleep(500 * (attempt+1));
          continue;
        }
      }
    }
    throw lastErr || new Error('fetch failed');
  }

  function yen(n){
    if (typeof n !== 'number') return '-';
    return n.toLocaleString('ja-JP', { style:'currency', currency:'JPY', maximumFractionDigits: 0 });
  }

  function openCoinGecko(coin){
    const id = coin?.id;
    if (id){
      const url = `https://www.coingecko.com/en/coins/${encodeURIComponent(id)}`;
      window.open(url, '_blank', 'noopener');
    } else {
      const q = encodeURIComponent(coin?.name || coin?.symbol || '');
      window.open(`https://www.coingecko.com/en/search?query=${q}`, '_blank', 'noopener');
    }
  }

  // ============ Data ============
  let marketsTop = [];          // top250
  let trendingCoins = [];
  const EXCLUDE_MCAP_IDS = new Set([
    "tether","usd-coin","dai","true-usd","first-digital-usd","ethena-usde",
    "pax-dollar","frax"
  ]);

  const EXCLUDE_MCAP_KEYWORDS = [
    "stable","tether","usd coin","us dollar"
  ];

  function isExcludedForMarketCap(c){
    const id = (c?.id || "").toLowerCase();
    const name = (c?.name || "").toLowerCase();
    const sym = (c?.symbol || "").toLowerCase();
    if (EXCLUDE_MCAP_IDS.has(id)) return true;
    return EXCLUDE_MCAP_KEYWORDS.some(k => name.includes(k) || sym.includes(k));
  }
  async function loadMarketsTop250(forceNetwork=false){
  const url = 'https://api.coingecko.com/api/v3/coins/markets'
    + '?vs_currency=jpy'
    + '&order=market_cap_desc'
    + '&per_page=250&page=1'
    + '&sparkline=true'
    + '&price_change_percentage=24h';

  // まずキャッシュで即表示（ネット失敗でも「真っ白」を避ける）
  const cached = readCache(LS_KEYS.markets);
  if (cached && Array.isArray(cached.data) && cached.data.length){
    marketsTop = cached.data;
  }

  // F5連打など短時間の再読み込みはネット取得をスキップ（API制限対策）
  const now = Date.now();
  const lastFetchAt = getLastFetchAt();
  const canSkipNetwork = !forceNetwork && (now - lastFetchAt) < BOOT_NETWORK_COOLDOWN_MS;
  if (canSkipNetwork && marketsTop.length){
    setStatus('保存済みデータを表示中（自動で最新に切り替わります）');
    return;
  }

  try{
    const fresh = await fetchJsonRetry(url, {retries:2});
    if (Array.isArray(fresh) && fresh.length){
      marketsTop = fresh;
      writeCache(LS_KEYS.markets, fresh);
      setLastFetchAt();
    } else if (!Array.isArray(marketsTop) || !marketsTop.length){
      marketsTop = [];
    }
  } catch (e){
    // キャッシュがあるならそれで継続。無いならエラーを投げる
    if (marketsTop && marketsTop.length){
      console.warn('markets fetch failed, using cache:', e);
      setStatus('最新データの取得が遅れています（保存済みデータを表示中）');
      return;
    }
    throw e;
  }
}


  async function loadTrendingTop5(forceNetwork=false){
  const trendUrl = 'https://api.coingecko.com/api/v3/search/trending';

  // キャッシュ（ids + 最小スナップショット）から先に組み立て
  function setFromCache(ids, snap){
    const idsArr = Array.isArray(ids) ? ids : (Array.isArray(snap) ? snap.map(x => x && x.id).filter(Boolean) : []);
    if (!idsArr.length){ trendingCoins = []; return; }

    const byIdTop = new Map(marketsTop.map(x => [x.id, x]));
    const byIdSnap = new Map((Array.isArray(snap) ? snap : []).filter(Boolean).map(x => [x.id, x]));

    trendingCoins = idsArr
      .map(id => byIdTop.get(id) || byIdSnap.get(id))
      .filter(Boolean);
  }

  const cachedIdsObj = readCache(LS_KEYS.trendingIds);
  const cachedSnapObj = readCache(LS_KEYS.trendingSnapshot);
  const cachedIds = (cachedIdsObj && Array.isArray(cachedIdsObj.data)) ? cachedIdsObj.data : null;
  const cachedSnap = (cachedSnapObj && Array.isArray(cachedSnapObj.data)) ? cachedSnapObj.data : null;

  const cachedIdsCount = cachedIds ? cachedIds.length : 0;
  const cachedSnapCount = cachedSnap ? cachedSnap.length : 0;

  if (cachedIdsCount || cachedSnapCount){
    setFromCache(cachedIds, cachedSnap);
  }

  // markets が取れていない場合は無理に進めない
  if (!marketsTop.length){
    trendingCoins = [];
    return;
  }

  // F5連打など短時間の再読み込みはネット取得をスキップ（API制限対策）
  const now = Date.now();
  const lastFetchAt = getLastFetchAt();
  const canSkipNetwork = !forceNetwork && (now - lastFetchAt) < BOOT_NETWORK_COOLDOWN_MS;

  // キャッシュIDsから組み立てた結果が5件未満（＝top250に無い銘柄が混ざっている等）の場合は、
  // クールダウン中でもネット取得を行って欠けを埋める
  const wantCount = Math.min(5, cachedIdsCount || cachedSnapCount || 5);
  const hasAllCached = trendingCoins.length >= wantCount;

  if (canSkipNetwork && hasAllCached){
    return;
  }

  try{
    const trendJson = await fetchJsonRetry(trendUrl, {retries:2});
    // NOTE: /search/trending の先頭5件に欠損(item/idなし)が混ざることがあるため、
    // idがあるものだけを拾ってから上位5件に絞る（#5が欠ける問題の対策）
    const trendItems = (trendJson.coins || [])
      .map(c => c.item)
      .filter(it => it && it.id)
      .slice(0,5);

    const ids = trendItems.map(it => it.id);

    if (!ids.length){ trendingCoins = []; return; }

    // top250 から拾う
    const byIdTop = new Map(marketsTop.map(x => [x.id, x]));

    // 不足があれば、そのidsだけ markets で1回取得（最小）
    const missing = ids.filter(id => !byIdTop.has(id));
    if (missing.length){
      const mUrl = 'https://api.coingecko.com/api/v3/coins/markets'
        + '?vs_currency=jpy'
        + '&ids=' + encodeURIComponent(missing.join(','))
        + '&sparkline=true'
        + '&price_change_percentage=24h';
      const extra = await fetchJsonRetry(mUrl, {retries:2});
      const extraArr = Array.isArray(extra) ? extra : [];
      for (const x of extraArr) byIdTop.set(x.id, x);
    }

    // それでも markets が取れないIDは、trendingレスポンスの item/data から最小オブジェクトを作って表示する
    const fallbackById = new Map(trendItems.map(it => [it.id, it]));
    trendingCoins = ids.map(id => {
      const m = byIdTop.get(id);
      if (m) return m;

      const it = fallbackById.get(id);
      if (!it) return null;

      // trending の data は形式が変わることがあるので、防御的に拾う
      const data = it.data || {};
      const spark = Array.isArray(data.sparkline) ? data.sparkline
        : (data.sparkline_in_7d && Array.isArray(data.sparkline_in_7d.price) ? data.sparkline_in_7d.price : null);

      // price_change_percentage_24h がオブジェクトの場合は jpy を優先、なければ最初の数値を拾う
      let pch = null;
      const pchAny = data.price_change_percentage_24h;
      if (typeof pchAny === 'number') pch = pchAny;
      else if (pchAny && typeof pchAny === 'object'){
        if (typeof pchAny.jpy === 'number') pch = pchAny.jpy;
        else {
          for (const v of Object.values(pchAny)){
            if (typeof v === 'number'){ pch = v; break; }
          }
        }
      }

      // price / volume は通貨別オブジェクトのことがある（jpy優先）
      const pickNum = (x) => {
        if (typeof x === 'number') return x;
        if (x && typeof x === 'object'){
          if (typeof x.jpy === 'number') return x.jpy;
          for (const v of Object.values(x)){
            if (typeof v === 'number') return v;
          }
        }
        return null;
      };

      const price = pickNum(data.price);
      const vol = pickNum(data.total_volume);

      return {
        id,
        name: it.name || id,
        symbol: it.symbol || '',
        image: it.small || it.thumb || '',
        market_cap_rank: it.market_cap_rank || null,
        current_price: price,
        total_volume: vol,
        price_change_percentage_24h: pch,
        // Chart.js の描画系が期待する形に合わせる
        sparkline_in_7d: spark ? { price: spark } : undefined,
      };
    }).filter(Boolean);

    writeCache(LS_KEYS.trendingIds, ids);

    // 最小スナップショットも保存（TOP250外の銘柄でも次回F5で5件を維持するため）
    const snap = (trendingCoins || []).slice(0,5).map(c => {
      const sp = c && c.sparkline_in_7d && Array.isArray(c.sparkline_in_7d.price) ? c.sparkline_in_7d.price : null;
      // localStorage肥大化を防ぐため、スパークラインは末尾最大240点だけ保持
      const spTrim = sp ? sp.filter(v => typeof v === 'number' && Number.isFinite(v)).slice(-240) : null;
      return {
        id: c.id,
        name: c.name,
        symbol: c.symbol,
        image: c.image,
        market_cap_rank: c.market_cap_rank ?? null,
        current_price: (typeof c.current_price === 'number' && Number.isFinite(c.current_price)) ? c.current_price : null,
        total_volume: (typeof c.total_volume === 'number' && Number.isFinite(c.total_volume)) ? c.total_volume : null,
        price_change_percentage_24h: (typeof c.price_change_percentage_24h === 'number' && Number.isFinite(c.price_change_percentage_24h)) ? c.price_change_percentage_24h : null,
        sparkline_in_7d: spTrim ? { price: spTrim } : undefined,
      };
    });
    writeCache(LS_KEYS.trendingSnapshot, snap);
  } catch (e){
    if (trendingCoins && trendingCoins.length){
      console.warn('trending fetch failed, using cache/top:', e);
      return;
    }
    throw e;
  }
}

function buildMarketCapTop20(){
    return marketsTop
      .filter(c => typeof c.market_cap === "number")
      .filter(c => !isExcludedForMarketCap(c))   // ← 追加
      .slice(0,20);
  }

function getMarketCapTop20(){
  if (marketsTop && marketsTop.length){
    const coins = buildMarketCapTop20();
    // mcapは20件なので、sparklineは保存せず（容量節約）。必要ならここで追加可。
    try{
      const snap = (coins || []).slice(0,20).map(c => {
        if(!c) return null;
        return {
          id: c.id,
          name: c.name,
          symbol: c.symbol,
          image: c.image,
          market_cap_rank: c.market_cap_rank ?? null,
          current_price: (typeof c.current_price === 'number' && Number.isFinite(c.current_price)) ? c.current_price : null,
          market_cap: (typeof c.market_cap === 'number' && Number.isFinite(c.market_cap)) ? c.market_cap : null,
          total_volume: (typeof c.total_volume === 'number' && Number.isFinite(c.total_volume)) ? c.total_volume : null,
          price_change_percentage_24h: (typeof c.price_change_percentage_24h === 'number' && Number.isFinite(c.price_change_percentage_24h)) ? c.price_change_percentage_24h : null,
        };
      }).filter(Boolean);
      writeCache(LS_KEYS.mcapSnapshot, snap);
    }catch(e){}
    return coins;
  }
  const cached = readCache(LS_KEYS.mcapSnapshot);
  const snap = (cached && Array.isArray(cached.data)) ? cached.data : null;
  return Array.isArray(snap) ? snap : [];
}



  function buildGainersTop5(){
    return marketsTop
      .filter(c => typeof c.price_change_percentage_24h === 'number')
      .slice()
      .sort((a,b) => b.price_change_percentage_24h - a.price_change_percentage_24h)
      .slice(0,5);
  }

  const EXCLUDE_VOLUME_IDS = new Set([
    "tether","usd-coin","dai","true-usd","first-digital-usd","ethena-usde",
    "wrapped-bitcoin","staked-ether"
  ]);

  const EXCLUDE_NAME_KEYWORDS = [
    "usd","us dollar","stable","tether","usd coin",
    "wrapped","bridged","wormhole","portal",
    "staked","staking","restaked",
    "wbtc","weth","steth"
  ];

  function isExcludedForAltVolume(c){
    const id = (c?.id || "").toLowerCase();
    const name = (c?.name || "").toLowerCase();
    const sym = (c?.symbol || "").toLowerCase();
    if (EXCLUDE_VOLUME_IDS.has(id)) return true;
    return EXCLUDE_NAME_KEYWORDS.some(k => name.includes(k) || sym.includes(k));
  }

  function buildVolumeTop5(){
    return marketsTop
      .filter(c => typeof c.total_volume === "number")
      .filter(c => !isExcludedForAltVolume(c))   // ← 追加
      .slice()
      .sort((a,b) => b.total_volume - a.total_volume)
      .slice(0,5);
  }
function getGainersTop5(){
  if (marketsTop && marketsTop.length){
    const coins = buildGainersTop5();
    writeSnapshot(LS_KEYS.gainersSnapshot, coins);
    return coins;
  }
  return readSnapshot(LS_KEYS.gainersSnapshot);
}

function getVolumeTop5(){
  if (marketsTop && marketsTop.length){
    const coins = buildVolumeTop5();
    writeSnapshot(LS_KEYS.volumeSnapshot, coins);
    return coins;
  }
  return readSnapshot(LS_KEYS.volumeSnapshot);
}



  // ============ Market Overview ============
  const STABLE_IDS = new Set(['tether','usd-coin','dai','first-digital-usd','true-usd','ethena-usde']);

  function fmtPct(n){
    if (typeof n !== 'number' || !isFinite(n)) return '-';
    const s = (n>=0?'+':'');
    return s + n.toFixed(2) + '%';
  }

  function buildOverview(){
    const arr = marketsTop || [];
    const n = arr.length;
    let totalMcap = 0;
    let totalVol = 0;

    let up = 0, down = 0, flat = 0;
    let sumChg = 0, chgN = 0;

    // Composition (market cap)
    let btc = 0, eth = 0, stable = 0, other = 0;
    // Composition (volume)
    let btcV = 0, ethV = 0, stableV = 0, otherV = 0;

    for (const c of arr){
      const mc = (typeof c.market_cap === 'number' && isFinite(c.market_cap)) ? c.market_cap : 0;
      const vol = (typeof c.total_volume === 'number' && isFinite(c.total_volume)) ? c.total_volume : 0;
      totalMcap += mc;
      totalVol += vol;

      const chg = c.price_change_percentage_24h;
      if (typeof chg === 'number' && isFinite(chg)){
        if (chg > 0) up++;
        else if (chg < 0) down++;
        else flat++;
        sumChg += chg;
        chgN++;
      }

      if (c.id === 'bitcoin'){ btc += mc; btcV += vol; }
      else if (c.id === 'ethereum'){ eth += mc; ethV += vol; }
      else if (STABLE_IDS.has(c.id)){ stable += mc; stableV += vol; }
      else { other += mc; otherV += vol; }
    }

    const avgChg = chgN ? (sumChg / chgN) : null;

    const labels = ['BTC','ETH','ステーブル','Others'];
    const values = [btc, eth, stable, Math.max(0, other)];
    const volValues = [btcV, ethV, stableV, Math.max(0, otherV)];

    return { labels, values, volValues, totalMcap, totalVol, up, down, flat, avgChg, chgN, n };
  }

  function drawDonut(canvasId, labels, values){
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    const total = values.reduce((a,b)=>a+(typeof b==='number'?b:0), 0) || 1;
    const dataVals = values.map(v => (typeof v==='number' && isFinite(v)) ? v : 0);

    // 見やすい落ち着いた色（サイトの雰囲気に合わせる）
    const colors = ['rgba(250, 204, 21, 0.85)','rgba(96, 165, 250, 0.85)','rgba(52, 211, 153, 0.85)','rgba(156, 163, 175, 0.55)'];

    charts[canvasId] = new Chart(canvas, {
      type: 'doughnut',
      data: {
        labels,
        datasets: [{ data: dataVals, backgroundColor: colors, borderWidth: 0 }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        plugins: {
          legend: {
            position: 'bottom',
            labels: { color: '#e5e7eb', boxWidth: 10, padding: 12 }
          },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const v = ctx.parsed || 0;
                const p = (v/total)*100;
                return ` ${ctx.label}: ${p.toFixed(2)}%`;
              }
            }
          }
        }
      }
    });
  }

  function renderOverview(){
    const msg = document.getElementById('overviewMsg');
    msg.style.display = 'none';

    if (!marketsTop || !marketsTop.length){
      msg.className = 'msg err';
      msg.textContent = '概況データを準備中です。';
      msg.style.display = 'block';
      return;
    }

    const o = buildOverview();

    // Breadth
    document.getElementById('kpiBreadth').textContent = `上昇 ${o.up} / 下落 ${o.down}`;
    const breadthSub = document.getElementById('kpiBreadthSub');
    if (breadthSub){
      const baseTxt = `対象: 上位250（取得 ${o.n}）のうち、24h騰落率が取得できた ${o.chgN} 銘柄を集計`;
      const flatTxt = (o.flat > 0) ? `（中立 ${o.flat}）` : '';
      breadthSub.textContent = `${baseTxt}${flatTxt}`;
    }

    const denom = (o.up + o.down + o.flat) || 1;
    const upPct = (o.up / denom) * 100;
    const flatPct = (o.flat / denom) * 100;
    const downPct = (o.down / denom) * 100;
    const barUp = document.getElementById('barUp');
    const barFlat = document.getElementById('barFlat');
    const barDown = document.getElementById('barDown');
    if (barUp) barUp.style.width = `${upPct}%`;
    if (barFlat) barFlat.style.width = `${flatPct}%`;
    if (barDown) barDown.style.width = `${downPct}%`;

    // Average change
    document.getElementById('kpiAvgChange').textContent = fmtPct(o.avgChg);
    const avgFill = document.getElementById('avgFill');
    if (avgFill){
      const maxRange = 5; // ±5% を目安に可視化（超過はクリップ）
      const v = (typeof o.avgChg === 'number' && isFinite(o.avgChg)) ? o.avgChg : 0;
      const w = Math.min(Math.abs(v), maxRange) / maxRange * 50; // 0..50
      if (v >= 0){
        avgFill.className = 'centerfill pos';
        avgFill.style.left = '50%';
        avgFill.style.width = `${w}%`;
      } else {
        avgFill.className = 'centerfill neg';
        avgFill.style.left = `${50 - w}%`;
        avgFill.style.width = `${w}%`;
      }
    }

    // Totals
    document.getElementById('kpiTotalMcap').textContent = yen(o.totalMcap);
    document.getElementById('kpiTotalVol').textContent = yen(o.totalVol);

    // Composition bars (market cap)
    const totalM = (o.values || []).reduce((a,b)=>a+((typeof b==='number'&&isFinite(b))?b:0), 0) || 1;
    const mPct = (o.values || []).map(v => (((typeof v==='number'&&isFinite(v))?v:0)/totalM)*100);
    const setW = (id, w) => { const el = document.getElementById(id); if (el) el.style.width = `${w}%`; };
    setW('mcapSegBtc', mPct[0] || 0);
    setW('mcapSegEth', mPct[1] || 0);
    setW('mcapSegStable', mPct[2] || 0);
    setW('mcapSegOther', mPct[3] || 0);

    // Composition bars (volume)
    const totalV = (o.volValues || []).reduce((a,b)=>a+((typeof b==='number'&&isFinite(b))?b:0), 0) || 1;
    const vPct = (o.volValues || []).map(v => (((typeof v==='number'&&isFinite(v))?v:0)/totalV)*100);
    setW('volSegBtc', vPct[0] || 0);
    setW('volSegEth', vPct[1] || 0);
    setW('volSegStable', vPct[2] || 0);
    setW('volSegOther', vPct[3] || 0);



    // ---- Overview line series (API追加なし: sparkline_in_7d から算出) ----
    try {
      const seriesLen = (marketsTop && marketsTop[0] && marketsTop[0].sparkline_in_7d && marketsTop[0].sparkline_in_7d.price) ? marketsTop[0].sparkline_in_7d.price.length : 0;
      if (seriesLen > 2) {
        const upArr = new Array(seriesLen).fill(0);
        const downArr = new Array(seriesLen).fill(0);
        const flatArr = new Array(seriesLen).fill(0);
        const avgArr = new Array(seriesLen).fill(0);
        const mcapArr = new Array(seriesLen).fill(0);
        const volArr = new Array(seriesLen).fill(0);
        const cntArr = new Array(seriesLen).fill(0);

        for (let i=0;i<marketsTop.length;i++){
          const c = marketsTop[i];
          const sp = c && c.sparkline_in_7d && c.sparkline_in_7d.price;
          if (!sp || sp.length !== seriesLen) continue;
          const p0 = sp[0];
          const plast = sp[seriesLen-1];
          if (!(p0>0) || !(plast>0)) continue;
          const mcNow = (typeof c.market_cap === 'number' && isFinite(c.market_cap)) ? c.market_cap : 0;
          const volNow = (typeof c.total_volume === 'number' && isFinite(c.total_volume)) ? c.total_volume : 0;
          for (let t=0;t<seriesLen;t++){
            const pt = sp[t];
            if (!(pt>0)) continue;
            const ret = (pt/p0 - 1) * 100;
            if (ret > 0) upArr[t] += 1;
            else if (ret < 0) downArr[t] += 1;
            else flatArr[t] += 1;
            avgArr[t] += ret;
            cntArr[t] += 1;
            // 推定: supply一定近似
            if (mcNow>0) mcapArr[t] += mcNow * (pt/plast);
            if (volNow>0) volArr[t] += volNow * (pt/plast);
          }
        }
        for (let t=0;t<seriesLen;t++){
          if (cntArr[t]>0) avgArr[t] = avgArr[t] / cntArr[t];
        }

        // Labels: just indexes (Chart.js will hide axis anyway)
        const labels = Array.from({length: seriesLen}, (_,i)=>i);

        // Breadth chart (3 lines)
        makeLineChart('breadthLine', labels, [
          {label:'上昇', data: upArr, border:'rgba(30,136,229,0.9)', fill:false},
          {label:'下落', data: downArr, border:'rgba(211,47,47,0.9)', fill:false},
          {label:'中立', data: flatArr, border:'rgba(156,163,175,0.7)', fill:false},
        ], {yBeginAtZero:true});

        // Avg return chart (0 baseline fill)
        makeBaselineChart('avgLine', labels, avgArr);
        // KPI表示を「7d推移」ベース（最新点）に合わせる
        const lastUp = upArr[upArr.length - 1];
        const lastDown = downArr[downArr.length - 1];
        const lastAvg = avgArr[avgArr.length - 1];
        document.getElementById('kpiBreadth').textContent = `上昇 ${lastUp} / 下落 ${lastDown}`;
        document.getElementById('kpiAvgChange').textContent = fmtPct(lastAvg);


        // Market cap estimate (normalize to last for readability)
        makeNormalizedLine('mcapLine', labels, mcapArr);

        // Volume estimate (normalize)
        makeNormalizedLine('volLine', labels, volArr);
      }
    } catch(e) { console.warn('overview series failed', e); }

    drawDonut('domChart', o.labels, o.values);
  }

// ============ Charts / Rendering ============
  const charts = {};
  const __sparklineAttempts = new Map(); // canvasId -> attempts

  function clearCharts(){
    Object.values(charts).forEach(c => { try{ c.destroy(); }catch(e){} });
    Object.keys(charts).forEach(k => delete charts[k]);
  }

function drawSparkline(canvasId, data){
  const canvas = document.getElementById(canvasId);
  if(!canvas) return;

  // If the canvas isn't laid out yet (size 0), retry a few times.
  const w = canvas.clientWidth || canvas.width;
  const h = canvas.clientHeight || canvas.height;
  if(!w || !h){
    const n = (__sparklineAttempts.get(canvasId) || 0) + 1;
    if(n <= 8){
      __sparklineAttempts.set(canvasId, n);
      requestAnimationFrame(() => drawSparkline(canvasId, data));
    }
    return;
  }
  __sparklineAttempts.delete(canvasId);

  const raw = Array.isArray(data) ? data : [];
  const cleaned = raw.map(v => (typeof v === "number" && Number.isFinite(v)) ? v : null);
  const finite = cleaned.filter(v => v !== null);

  const ctx = canvas.getContext("2d");
  if(finite.length < 2){
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    return;
  }

  const base = finite[0];                 // ← ベースライン（最初の値）
  const enableFill = finite.length >= 10; // 少なすぎる時は塗らない

  try{
    if(charts[canvasId]) charts[canvasId].destroy();

    charts[canvasId] = new Chart(ctx, {
      type: "line",
      data: {
        labels: cleaned.map((_, i) => i),
        datasets: [{
          data: cleaned,
          borderColor: "rgba(255,255,255,0.85)",
          borderWidth: 1.5,
          pointRadius: 0,
          tension: 0.25,

          // ★ここがポイント：ベースライン(base)より上/下で塗り分け
          fill: enableFill ? {
            target: { value: base },
            above: "rgba(30,136,229,0.22)", // 青
            below: "rgba(211,47,47,0.22)"   // 赤
          } : false,

          // fill の above/below を使うので、dataset の backgroundColor は透明でOK
          backgroundColor: "rgba(0,0,0,0)",
          spanGaps: true
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        plugins: { legend: { display:false }, tooltip: { enabled:false } },
        scales: { x: { display:false }, y: { display:false } }
      }
    });
  }catch(err){
    console.warn("sparkline render failed:", canvasId, err);
    try{ if(charts[canvasId]) charts[canvasId].destroy(); }catch{}
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
}


function buildSyntheticSparkline(coin){
  // Last-resort mini sparkline from 24h change (2 points) so the canvas is never blank.
  const p1 = (coin && typeof coin.current_price === 'number' && Number.isFinite(coin.current_price)) ? coin.current_price : null;
  const ch = (coin && typeof coin.price_change_percentage_24h === 'number' && Number.isFinite(coin.price_change_percentage_24h)) ? coin.price_change_percentage_24h : null;
  if(p1 === null || ch === null) return [];
  const denom = 1 + (ch / 100);
  if(!Number.isFinite(denom) || denom === 0) return [];
  const p0 = p1 / denom;
  if(!Number.isFinite(p0)) return [];
  return [p0, p1];
}

function hasAtLeast2Finite(arr){
  if(!Array.isArray(arr)) return false;
  let n = 0;
  for(const v of arr){
    if(typeof v === "number" && Number.isFinite(v)){
      n++;
      if(n >= 2) return true;
    }
  }
  return false;
}

// --- Sparkline fallback (when sparkline_in_7d is missing) ---
const __sparklineFallbackCache = new Map(); // coinId -> Promise<number[]>

function fetchSparkline7dFallback(coinId){
  if(!coinId) return Promise.resolve([]);
  if(__sparklineFallbackCache.has(coinId)) return __sparklineFallbackCache.get(coinId);
  const url = `https://api.coingecko.com/api/v3/coins/${encodeURIComponent(coinId)}/market_chart?vs_currency=jpy&days=7`;
  const p = fetchJsonRetry(url, { retries: 1 }).then(j => {
    const arr = (j && Array.isArray(j.prices)) ? j.prices.map(x => x && x[1]).filter(v => typeof v === "number") : [];
    return arr;
  }).catch(() => []);
  __sparklineFallbackCache.set(coinId, p);
  return p;
}

// --- Sparkline 24h (1d) for gainers/volume (keeps % change label consistent) ---
const __sparkline1dCache = new Map(); // coinId -> Promise<number[]>
function fetchSparkline1d(coinId){
  if(!coinId) return Promise.resolve([]);
  if(__sparkline1dCache.has(coinId)) return __sparkline1dCache.get(coinId);
  const url = `https://api.coingecko.com/api/v3/coins/${encodeURIComponent(coinId)}/market_chart?vs_currency=jpy&days=1`;
  const p = fetchJsonRetry(url, { retries: 1 }).then(j => {
    const arr = (j && Array.isArray(j.prices)) ? j.prices.map(x => x && x[1]).filter(v => typeof v === "number") : [];
    return arr;
  }).catch(() => []);
  __sparkline1dCache.set(coinId, p);
  return p;
}


  // 7日スパークラインから「直近24h相当」を切り出す（追加APIを減らして欠損を防ぐ）
  function derive24hFrom7d(spark7d) {
    if (!Array.isArray(spark7d)) return [];
    const len = spark7d.length;
    if (len <= 2) return spark7d;
    // 7日→24h は 1/7。Coingecko の sparkline はだいたい時間間隔が一定なので割合で切り出す
    const n = Math.max(12, Math.round(len / 7));
    return spark7d.slice(-Math.min(n, len));
  }


  function ensureChartjs(){ return (typeof Chart !== 'undefined'); }

  function makeLineChart(canvasId, labels, series, opts){
    if (!ensureChartjs()) return;
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const datasets = series.map(s => ({
      label: s.label,
      data: s.data,
      pointRadius: 0,
      borderWidth: 2,
      borderColor: s.border,
      tension: 0.25,
      fill: false,
    }));
    charts[canvasId] = new Chart(canvas, {
      type: 'line',
      data: { labels: labels, datasets: datasets },
      options: {
        responsive: true, maintainAspectRatio: false, animation: false,
        plugins: { legend: { display: false }, tooltip: { enabled: false } },
        scales: { x: { display:false }, y: { display:false, beginAtZero: !!(opts && opts.yBeginAtZero) } }
      }
    });
  }

  function makeBaselineChart(canvasId, labels, dataArr){
    if (!ensureChartjs()) return;
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    charts[canvasId] = new Chart(canvas, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          data: dataArr,
          pointRadius: 0,
          borderWidth: 2,
          borderColor: '#e5e7eb',
          tension: 0.25,
          fill: {
            target: { value: 0 },
            above: 'rgba(30, 136, 229, 0.22)',
            below: 'rgba(211, 47, 47, 0.22)'
          }
        }]
      },
      options: {
        responsive:true, maintainAspectRatio:false, animation:false,
        plugins:{ legend:{display:false}, tooltip:{enabled:false} },
        scales:{ x:{display:false}, y:{display:false} }
      }
    });
  }

  function makeNormalizedLine(canvasId, labels, dataArr){
    if (!ensureChartjs()) return;
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const last = dataArr && dataArr.length ? dataArr[dataArr.length-1] : 0;
    const norm = (last && isFinite(last) && last!=0) ? dataArr.map(v => (v/last)*100) : dataArr.map(_=>0);
    charts[canvasId] = new Chart(canvas, {
      type:'line',
      data:{ labels: labels, datasets:[{
        data: norm,
        pointRadius:0,
        borderWidth:2,
        borderColor:'#e5e7eb',
        tension:0.25,
        fill:false
      }]},
      options:{ responsive:true, maintainAspectRatio:false, animation:false,
        plugins:{ legend:{display:false}, tooltip:{enabled:false} },
        scales:{ x:{display:false}, y:{display:false} }
      }
    });
  }

  function renderInto(gridId, coins, mode, sectionKey){
    const grid = document.getElementById(gridId);
    grid.innerHTML = '';

    if (!coins || !coins.length){
      grid.innerHTML = '<div class="msg">最新データの取得が遅れています。時間をおいて再読み込みしてください。</div>';
      return;
    }

    coins.forEach((coin, idx) => {
      const change = coin.price_change_percentage_24h;
      const trendClass = (typeof change === 'number') ? (change >= 0 ? 'up' : 'down') : '';
      const changeClass = (typeof change === 'number') ? (change >= 0 ? 'positive' : 'negative') : '';

      const card = document.createElement('div');
      card.className = `card ${trendClass}`;
      card.onclick = () => openCoinGecko(coin);

      const rankCls = idx===0 ? 'rank-1' : idx===1 ? 'rank-2' : idx===2 ? 'rank-3' : '';

      const pctText = (typeof change === 'number')
        ? ((change>=0?'+':'') + change.toFixed(2) + '%')
        : '-';

      const rankText = coin.market_cap_rank ? ('#' + coin.market_cap_rank) : '-';
      const volMeta = (typeof coin.total_volume === 'number')
        ? `出来高(24h): ${yen(coin.total_volume)}`
        : '出来高(24h): -';

      const extraMeta = (mode==='mcap')
        ? `時価総額: ${yen(coin.market_cap)} / 順位: ${rankText}`
        : `時価総額順位: ${rankText}`;

      const canvasId = `sp_${sectionKey}_${(coin.id || coin.symbol || idx)}`;

      card.innerHTML = `
        <div class="rank-badge ${rankCls}">#${idx+1}</div>
        <div class="card-header">
          <div class="coin-header">
            <img class="coin-icon" src="${coin.image}" alt="${coin.name}">
            <div>
              <div class="coin-name">${coin.name}</div>
              <div class="coin-symbol">${(coin.symbol||'').toUpperCase()}</div>
            </div>
          </div>
          <div>
            <div class="price">${yen(coin.current_price)}</div>
            <div class="change ${changeClass}">24h: ${pctText}</div>
            <div class="meta">${volMeta}</div>
            <div class="meta">${extraMeta}</div>
          </div>
        </div>
        <canvas id="${canvasId}" class="sparkline" aria-label="price chart" role="img"></canvas>
      `;

      grid.appendChild(card);

      // Sparkline:
      // mcapスナップショットではsparklineを保存しないため、無い場合はフェッチせずスキップ（API節約）
      if (mode==='mcap' && !(coin && coin.sparkline_in_7d && Array.isArray(coin.sparkline_in_7d.price) && coin.sparkline_in_7d.price.length)){
        return;
      }
      // be defensive. If anything goes wrong, fall back to a tiny synthetic line.
      const ensureSparklineLater = () => {
        // If no chart instance after layout/async, draw a 2-point synthetic line as last resort.
        setTimeout(() => {
          try{
            if (!charts[canvasId]){
              const syn = buildSyntheticSparkline(coin);
              if (hasAtLeast2Finite(syn)) drawSparkline(canvasId, syn);
            }
          }catch(_e){}
        }, 600);
      };

      try{

      const use24h = (sectionKey === 'gainers' || sectionKey === 'volume');
      if (use24h){
        // まずは markets(sparkline_in_7d) から 24h 相当を切り出して描画（追加APIを減らす）
        const sp7 = coin?.sparkline_in_7d?.price;
        const sp24 = derive24hFrom7d(sp7);
        if (hasAtLeast2Finite(sp24)) {
          drawSparkline(canvasId, sp24);
        } else {
          // フォールバック（まれに sparkline が欠ける場合）
          fetchSparkline1d(coin.id).then(arr => {
            if (hasAtLeast2Finite(arr)) {
              drawSparkline(canvasId, arr);
            } else {
              const syn = buildSyntheticSparkline(coin);
              if (hasAtLeast2Finite(syn)) drawSparkline(canvasId, syn);
            }
          });
        }
      } else {
        const sp = coin?.sparkline_in_7d?.price;
        drawSparkline(canvasId, sp);
        // Fallback: some coins don't return sparkline_in_7d (new listings etc.)
        if (!hasAtLeast2Finite(sp)) {
          fetchSparkline7dFallback(coin.id).then(arr => {
            if (hasAtLeast2Finite(arr)) {
              drawSparkline(canvasId, arr);
            } else {
              const syn = buildSyntheticSparkline(coin);
              if (hasAtLeast2Finite(syn)) drawSparkline(canvasId, syn);
            }
          });
        }
      }
      } catch(e){
        console.warn('sparkline failed:', coin?.id || coin?.symbol || idx, e);
        const syn = buildSyntheticSparkline(coin);
        if (hasAtLeast2Finite(syn)) drawSparkline(canvasId, syn);
      }
      ensureSparklineLater();
    });
  }

  function renderAll(){
    clearCharts();
    renderInto('grid-trend', trendingCoins, 'trend', 'trend');
    renderInto('grid-gainers', getGainersTop5(), 'gainers', 'gainers');
    renderInto('grid-volume', getVolumeTop5(), 'volume', 'volume');
    renderInto('grid-mcap', getMarketCapTop20(), 'mcap', 'mcap');
    renderOverview();
  }

  function setLoadingAll(){
    document.getElementById('grid-trend').innerHTML = '<div class="msg">データ取得中…</div>';
    document.getElementById('grid-gainers').innerHTML = '<div class="msg">データ取得中…</div>';
    document.getElementById('grid-volume').innerHTML = '<div class="msg">データ取得中…</div>';
    document.getElementById('grid-mcap').innerHTML = '<div class="msg">データ取得中…</div>';
    const om = document.getElementById('overviewMsg');
    if (om){ om.style.display='none'; om.textContent=''; }
  }

  // ============ Boot ============
  async function init(fromManualRefresh=false){
    setLoadingAll();

    try{
      setStatus('markets取得中…');
      await loadMarketsTop250(fromManualRefresh);

      if (!marketsTop.length){
        setStatus('marketsが空です');
        document.getElementById('grid-mcap').innerHTML = '<div class="msg">データの取得が遅れています。時間をおいて再読み込みしてください。</div>';
        document.getElementById('grid-trend').innerHTML = '<div class="msg">---</div>';
        document.getElementById('grid-gainers').innerHTML = '<div class="msg">---</div>';
        document.getElementById('grid-volume').innerHTML = '<div class="msg">---</div>';
        return;
      }

      setStatus('トレンド取得中…');
      await loadTrendingTop5(fromManualRefresh);

      setUpdated();
      setStatus(fromManualRefresh ? '更新しました' : '表示準備完了');
      renderAll();

      markRefreshed();

    } catch(e){
      console.error('init failed:', e);
      setStatus('取得が一時的に不安定です');
      document.getElementById('grid-trend').innerHTML = '<div class="msg">データの取得が一時的に不安定です。時間をおいて再読み込みしてください。</div>';
      document.getElementById('grid-gainers').innerHTML = '<div class="msg">---</div>';
      document.getElementById('grid-volume').innerHTML = '<div class="msg">---</div>';
      document.getElementById('grid-mcap').innerHTML = '<div class="msg">---</div>';
    }
  }

  // 初回ロード
  (function boot(){
    tickRefreshButton();
    startUpdatedTicker();
    startAutoRefresh();
    init(false);
  })();
</script>

<script src="/assets/click_tracker.js" defer></script>

<footer class="site-footer">
  <div class="footer-inner">
    <div class="footer-note">
      免責：CoinRaderは情報提供目的であり投資助言ではありません。投資判断は自己責任でお願いします。<br>
      Data: CoinGecko（API制限・通信障害等により表示が遅延/欠損する場合があります）/ 広告・PRを含む場合があります。
    </div>

    <nav class="footer-links" aria-label="Footer links">
      <a href="./disclaimer.html">免責・リスク</a>
      <a href="./data-sources.html">データソース</a>
      <a href="./ads-pr.html">広告・PR表記</a>
      <a href="./privacy.html">プライバシーポリシー</a>
      <a href="./contact.html">お問い合わせ</a>
      <a href="./about.html">運営者情報</a>
    </nav>

    <div class="footer-copy">© CoinRader / Operator: CoinRader</div>
  </div>
</footer>
</body>
</html>
