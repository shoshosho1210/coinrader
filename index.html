<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>

<title>CoinRader - 暗号資産ダッシュボード | AI市場分析 & ビットコイン相場</title>

<meta content="CoinRader（コインレーダー）は、AIが市場トレンドを即時分析し、ビットコインの相場状況を示唆する投資家向けダッシュボードです。RSI、恐怖指数、出来高分析をリアルタイムで可視化し、トレード判断をサポートします。" name="description"/>
<meta content="index, follow" name="robots"/>
<link href="https://coinrader.net/" rel="canonical"/>

<meta content="ja_JP" property="og:locale"/>
<meta content="website" property="og:type"/>
<meta content="CoinRader" property="og:site_name"/>
<meta content="CoinRader - 暗号資産ダッシュボード" property="og:title"/>
<meta content="CoinRader（コインレーダー）：AIが市場トレンドを即時分析。ビットコインの状況を可視化する投資家向けダッシュボード。" property="og:description"/>
<meta content="https://coinrader.net/" property="og:url"/>

<meta content="https://coinrader.net/assets/og/ogp.png" property="og:image"/>
<meta content="1200" property="og:image:width"/>
<meta content="630" property="og:image:height"/>

<meta content="summary_large_image" name="twitter:card"/>
<meta content="CoinRader - 暗号資産ダッシュボード" name="twitter:title"/>
<meta content="AI市場分析、恐怖指数、RSI、ハッシュレートをリアルタイム表示。" name="twitter:description"/>
<meta content="https://coinrader.net/assets/og/ogp.png" name="twitter:image"/>

<link href="/assets/icons/favicon.ico" rel="icon"/>
<link href="/assets/icons/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"/>
<link href="/assets/icons/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"/>

<link href="/assets/icons/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180"/>
<link href="/assets/icons/apple-touch-icon.png" rel="icon" sizes="180x180" type="image/png"/>

<link href="/site.webmanifest" rel="manifest"/>
<meta content="#0f172a" name="theme-color"/>

<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link href="https://fonts.gstatic.com" rel="preconnect" crossorigin/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"/>

<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-TDEBXC7DH6"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-TDEBXC7DH6');
</script>
</head>

<style>
  .hero{padding:28px 0 16px;}
  .hero-inner{max-width:1600px;margin:0 auto;padding:0 18px;}
  .hero-copy{padding:18px 16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;
    background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));}
  .hero-badges{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
  .badge{font-size:12px;padding:4px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.04);color:rgba(229,231,235,.9)}
  .hero-title{margin:8px 0 8px;font-size:28px;line-height:1.2;letter-spacing:.2px}
  .hero-sub{margin:0 0 14px;color:rgba(229,231,235,.85);font-size:14px;line-height:1.7}
  .hero-cta{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:6px 0 6px}
  .hero-note{margin:10px 0 0;color:rgba(229,231,235,.55);font-size:12px}

  /* PC/スマホの改行制御 */
  .br-sp{display:none}
  .br-pc{display:inline}

  @media (max-width: 640px){
    .hero{padding:18px 0 10px}
    .hero-title{font-size:22px}
    .hero-cta .btn{width:100%;text-align:center}
    .br-sp{display:inline}
    .br-pc{display:none}
  }
  *{ box-sizing:border-box; }
  body{
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    background:#0f172a; color:#e5e7eb; margin:0; padding:12px;
  padding-top: calc(var(--hdr-h) + 12px);
}
  h1{ margin:6px 4px 10px; font-size:20px; letter-spacing:.2px; }

  .topbar{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin:0 4px 10px; }
  .pill{ border:1px solid #374151; background:#111827; color:#e5e7eb; border-radius:999px; padding:6px 10px; font-size:12px; }
  .btn{
    padding:8px 12px; border-radius:999px; border:1px solid #374151;
    background:#111827; color:#e5e7eb; cursor:pointer; font-size:12px;
  }
  .btn.primary{ background:#1e88e5; border-color:#1e88e5; color:#fff; }
  .btn:disabled{ opacity:.55; cursor:not-allowed; }

  .nav{ display:flex; gap:8px; flex-wrap:wrap; margin:0 4px 14px; }
  .nav .btn{ padding:6px 12px; font-size:12px; }

  section{ margin:0 4px 18px; max-width:none; padding:0; }
.section-header{ display:flex; align-items:flex-end; justify-content:space-between; gap:12px; margin:0 0 10px; }
  .section-title{ font-size:15px; font-weight:700; color:#f9fafb; }
  .section-sub{ font-size:12px; color:#9ca3af; margin-top:3px; }
  .section-actions{ display:flex; gap:8px; align-items:center; }
  .linkbtn{
    display:inline-flex; align-items:center; justify-content:center;
    text-decoration:none; color:#e5e7eb;
    border:1px solid #374151; background:#111827;
    padding:6px 10px; border-radius:999px; font-size:12px;
  }
  .linkbtn:hover{ border-color:#6b7280; }

  .grid{
    display:grid;
    gap:12px;
    align-items:stretch;
    grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
  }

  /* 1200px以上は必ず5列 */
  @media (min-width: 1200px){
    .grid{ grid-template-columns: repeat(5, minmax(0, 1fr)); }
  }

  
  /* ===== Smooth auto-refresh (keep cards visible) ===== */
  .grid.refreshing{ position:relative; }
  .grid.refreshing::after{
    content:"更新中…";
    position:absolute;
    top:10px; right:12px;
    font-size:11px;
    color:rgba(229,231,235,.85);
    background:rgba(17,24,39,.65);
    border:1px solid rgba(148,163,184,.25);
    padding:2px 8px;
    border-radius:999px;
    pointer-events:none;
    z-index:3;
  }
  .grid.refreshing .card{ opacity:.96; }
/* responsive columns (uniform across sections) */
  .card{
    position:relative; background:#111827; border-radius:12px; padding:10px 12px;
    box-shadow:0 6px 18px rgba(0,0,0,0.45); cursor:pointer;
    transition:transform .15s ease, box-shadow .15s ease;
    overflow:hidden;
    min-width:0;
  }
  /* ===== Card height / bottom alignment (index grids) ===== */
  .grid .card{
    display:flex;
    flex-direction:column;
    height:100%;
  }

  /* 上部（ヘッダー/テキスト）は上に寄せたまま */
  .grid .card .card-header{
    flex:0 0 auto;
  }

  /* スパークライン（カード内のcanvas）を常に下端に寄せる */
  .grid .card canvas{
    margin-top:auto !important;
  }

  /* 念のため：余白を統一（カード内の最後が詰まり過ぎないように） */
  .grid .card canvas{
    margin-bottom:2px;
  }

  .card:hover{ transform:translateY(-2px); box-shadow:0 10px 22px rgba(0,0,0,.5); }

  .card.up{ border-left:4px solid #1e88e5; }
  .card.down{ border-left:4px solid #d32f2f; }

  .rank-badge{
    position:absolute; top:8px; left:8px; width:32px; height:20px;
    display:flex; align-items:center; justify-content:center;
    font-size:13px; font-weight:700; border-radius:6px; color:#fff;
    background:#374151; z-index:2;
  }
  .rank-1{ background:#facc15; color:#111827; }
  .rank-2{ background:#9ca3af; color:#111827; }
  .rank-3{ background:#b45309; color:#fff; }

  .card-header{ display:flex; justify-content:space-between; align-items:flex-start; gap:10px; }
  .coin-header{ display:flex; align-items:center; gap:8px; padding-left:36px; min-width:0; }
  .coin-icon{ width:28px; height:28px; border-radius:50%; }
  .coin-name{ font-weight:600; font-size:14px; color:#f9fafb; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:150px; }
  .coin-symbol{ font-size:11px; color:#9ca3af; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .price{ font-size:15px; font-weight:600; color:#f9fafb; text-align:right; }
  .meta{ font-size:11px; color:#9ca3af; text-align:right; margin-top:2px; }
  .change{ font-size:12px; text-align:right; margin-top:2px; }
  .positive{ color:#4ade80; }
  .negative{ color:#f87171; }

  canvas{ display:block; width:100% !important; height:48px !important; margin-top:6px; }

  .msg{ grid-column:1 / -1; padding:10px 8px; color:#9ca3af; }
  .msg.err{ color:#f87171; }

  /* Market Overview */
  .overview{ display:grid; grid-template-columns: 1fr; gap:12px; }
  .overview.is-collapsed{display:none;}
  @media (min-width: 900px){ .overview{ grid-template-columns: 360px 1fr; } }
 
  .overview-card{ background:#111827; border-radius:12px; padding:12px; box-shadow:0 6px 18px rgba(0,0,0,0.45); }
  .overview-note{ font-size:11px; color:#9ca3af; margin-top:8px; }
  .donut-wrap{ width:100%; max-width:340px; aspect-ratio:1/1; margin:0 auto; }
  .donut-wrap canvas{ width:100% !important; height:100% !important; margin-top:0; }
  .dom-metrics{ margin-top:10px; font-size:12px; color:#cbd5e1; line-height:1.4; text-align:center; }
 
  .kpi-grid{ display:grid; grid-template-columns: repeat(1, minmax(0,1fr)); gap:10px; }
  @media (min-width: 560px){ .kpi-grid{ grid-template-columns: repeat(2, minmax(0,1fr)); } }
 
  .kpi{ border:1px solid #1f2937; border-radius:12px; padding:10px 12px; background:#0b1220; }
  .kpi-label{ font-size:11px; color:#9ca3af; }
  .kpi-value{ margin-top:6px; font-size:16px; font-weight:700; color:#f9fafb; }

  .kpi-canvas{ width:100% !important; height:70px !important; margin-top:8px; }
  .kpi-canvas.tall{ height:78px !important; }
  .kpi-canvas.tiny{ height:46px !important; opacity:.8; }
  #sentLine{ height:72px !important; opacity:1 !important; }

  /* RSI threshold overlay (30/70) - DOM overlay (pixel-aligned via JS) */
  .rsi-chart-wrap{ margin-top:8px; }
  .rsi-chart-area{ position:relative; height:70px; width:100%; }
  .rsi-chart-area .rsi-th{
    display:none; /* thresholds are drawn on-canvas for perfect alignment */
    position:absolute; left:0; right:0;
    height:2px;
    pointer-events:none;
    z-index:2;
    opacity:0.9;
  }
  /* upper threshold (70) */
  .rsi-chart-area .rsi-70{ background: rgba(239,68,68,0.65); } /* red */
  /* lower threshold (30) */
  .rsi-chart-area .rsi-30{ background: rgba(59,130,246,0.65); } /* blue */

  .rsi-chart-area > canvas{
    position:absolute; inset:0;
    width:100% !important; height:100% !important;
    margin:0 !important;
    z-index:1;
  }

  /* Sentiment gauge (Fear & Greed 代替) */
  .sent-gauge-wrap{ display:flex; justify-content:flex-start; align-items:flex-end; gap:14px; margin-top:10px; }
  .sent-gauge{
    width:220px; height:110px; position:relative; overflow:hidden;
    border-radius:220px 220px 0 0;
    background: conic-gradient(from 180deg,
      #ef4444 0deg 36deg,
      #f97316 36deg 72deg,
      #eab308 72deg 108deg,
      #22c55e 108deg 144deg,
      #16a34a 144deg 180deg,
      rgba(0,0,0,0) 180deg 360deg
    );
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.10);
  }
  .sent-gauge::before{
    content:"";
    position:absolute; left:12px; right:12px; bottom:-98px;
    width:auto; height:196px;
    background: rgba(15,23,42,.92);
    border-radius:999px;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.10);
  }
  .sent-needle{
    position:absolute; left:50%; bottom:0;
    width:2px; height:96px;
    background: rgba(255,255,255,.92);
    transform-origin: bottom center;
    transform: translateX(-50%) rotate(0deg);
    filter: drop-shadow(0 2px 6px rgba(0,0,0,.4));
  }
  .sent-needle::after{
    content:"";
    position:absolute; left:50%; bottom:-6px;
    width:14px; height:14px;
    background: rgba(255,255,255,.92);
    border-radius:999px;
    transform: translateX(-50%);
    box-shadow: 0 6px 14px rgba(0,0,0,.35);
  }
  .sent-gauge-meta{ display:flex; flex-direction:column; gap:4px; }
  .sent-gauge-score{ font-size:26px; font-weight:800; letter-spacing:.2px; }
  .sent-gauge-label{ font-size:12px; color: rgba(229,231,235,.75); }


  /* --- Market Overview KPI strip (シアン・デザイン・アップデート) --- */
  .overview-kpi-strip {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 10px;
    margin: 12px 0 14px;
  }

  .kpi-tile {
    background: rgba(15, 23, 42, 0.7) !important; /* 背景を少し深く */
    border: 1px solid rgba(56, 189, 248, 0.25) !important; /* 控えめな水色枠 */
    border-radius: 14px;
    padding: 10px 12px;
    position: relative;
    transition: all 0.3s ease;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
  }

  /* ホバー時に発光させる */
  .kpi-tile:hover {
    border-color: rgba(56, 189, 248, 0.5) !important;
    box-shadow: 0 0 15px rgba(56, 189, 248, 0.15);
    background: rgba(15, 23, 42, 0.8) !important;
  }

  .kpi-tile-title {
    font-size: 11px;
    color: #94a3b8; /* テキストを少し落ち着かせる */
    letter-spacing: .02em;
    font-weight: 600;
  }

  .kpi-tile-big {
    margin-top: 6px;
    font-size: 18px;
    font-weight: 800;
    color: #f8fafc !important; /* 数値は明るく白く */
    line-height: 1.1;
  }

  .kpi-tile-sub {
    margin-top: 4px;
    font-size: 11px;
    color: #cbd5e1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .kpi-tile-sub .pos{color:#4ade80;font-weight:700;}
  .kpi-tile-sub .neg{color:#f87171;font-weight:700;}
  
  /* Summary KPI compact rows */
  .summary-kpis .kpi-tile{ padding:9px 12px; }
  .summary-kpis .kpi-value-row{ display:flex; align-items:baseline; gap:10px; margin-top:6px; flex-wrap:wrap; }
  /* Keep value row on one line for some KPI tiles */
  .summary-kpis .kpi-tile.kpi-avg250 .kpi-value-row{ flex-wrap:nowrap; }
  .summary-kpis .kpi-tile.kpi-breadth .kpi-value-row{ flex-wrap:nowrap; }
  .summary-kpis .kpi-tile.kpi-dom .kpi-value-row{ flex-wrap:nowrap; }
  .summary-kpis .kpi-tile.kpi-dom #sumDomSub{ white-space:nowrap; font-size:12px; opacity:.95; }
  .summary-kpis .kpi-tile-big{ margin-top:0; }
  .summary-kpis .kpi-tile-sub.inline{ margin-top:0; font-size:12px; color:#cbd5e1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  
  .kpi-bar-caption{margin-top:6px;font-size:10px;line-height:1.2;text-align:center;color:rgba(229,231,235,0.60);min-height:12px;letter-spacing:.2px;user-select:none;}
.summary-kpis .mini-vis{ margin-top:6px; }
@media (max-width: 520px){ .overview-kpi-strip{grid-template-columns:repeat(2,minmax(0,1fr));} .kpi-tile-big{font-size:16px;} }

  .kpi-sub{ margin-top:6px; font-size:11px; color:#9ca3af; line-height:1.35; }
#kpiBreadthCard .kpi-meta{ margin-top:4px; }
#kpiBreadthCard .kpi-sub{ margin-top:4px; }
#kpiBreadthCard .kpi-canvas.tall{ height:62px; }

  .kpi-meta{ margin-top:6px; font-size:12px; color:#d1d5db; }


  .kpi-stack .kpi-block-title{ margin-top:10px; font-size:11px; color:#cbd5e1; }
  .kpi-stack .kpi-block:first-of-type .kpi-block-title{ margin-top:6px; }
  .kpi-stack .kpi-divider{ height:1px; background:#1f2937; margin:10px 0; opacity:.95; }


  .kpi-legend{ margin-top:6px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:11px; color:#9ca3af; }
  .kpi-legend .item{ display:inline-flex; align-items:center; gap:6px; }
  .kpi-legend .dot{ width:8px; height:8px; border-radius:999px; display:inline-block; }
  .kpi-legend .dot.up{ background:rgba(30,136,229,0.9); }
  .kpi-legend .dot.down{ background:rgba(211,47,47,0.9); }

  .barline{ margin-top:8px; height:10px; width:100%; border-radius:999px; overflow:hidden; background:#0f172a; border:1px solid #1f2937; display:flex; }
  .bar-up{ background:rgba(30,136,229,0.75); height:100%; }
  .bar-down{ background:rgba(211,47,47,0.75); height:100%; }
  .bar-flat{ background:rgba(156,163,175,0.55); height:100%; }

  .centerbar{ margin-top:8px; height:10px; width:100%; border-radius:999px; overflow:hidden; background:#0f172a; border:1px solid #1f2937; position:relative; }
  .centerline{ position:absolute; left:50%; top:0; width:1px; height:100%; background:#334155; }
  .centerfill{ position:absolute; top:0; height:100%; border-radius:999px; }
  .centerfill.pos{ background:rgba(30,136,229,0.75); }
  .centerfill.neg{ background:rgba(211,47,47,0.75); }

  .stackbar{ margin-top:8px; height:10px; width:100%; border-radius:999px; overflow:hidden; background:#0f172a; border:1px solid #1f2937; display:flex; }
  .seg{ height:100%; }
  .seg.btc{ background:rgba(250,204,21,0.85); }
  .seg.eth{ background:rgba(96,165,250,0.85); }
  .seg.stable{ background:rgba(52,211,153,0.85); }
  .seg.other{ background:rgba(156,163,175,0.55); }
  /* Footer */
  .site-footer{
    margin-top: 28px;
    padding: 18px 14px;
    border-top: 1px solid rgba(255,255,255,0.08);
    color: rgba(229,231,235,0.85);
  }
  .footer-inner{ max-width: 1200px; margin: 0 auto; }
  .footer-note{ font-size: 12px; line-height: 1.6; opacity: 0.95; }
  .footer-links{
    display: flex; flex-wrap: wrap; gap: 10px 14px;
    margin-top: 10px;
  }
  .footer-links a{
    font-size: 12px;
    color: rgba(229,231,235,0.9);
    text-decoration: underline;
    text-underline-offset: 2px;
  }
  .footer-copy{ margin-top: 10px; font-size: 12px; opacity: 0.75; }
  .brand { margin: 0 4px 6px; }
  .brandLink { display: inline-block; }
  .brandLogo{
    height: 28px;
    width: auto;
    display: block;
  }
  .btn-cta{
    display:inline-flex; align-items:center; justify-content:center;
    padding:9px 14px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.18);
    background:rgba(255,255,255,.06);
    color:#e5e7eb;
    text-decoration:none;
    font-weight:700;
  }
  .btn-cta:hover{ background:rgba(255,255,255,.10); }
  /* ===== CTA (収益導線) ===== */
  .cta-block{
    margin: 0 4px 18px;
    padding: 12px 12px;
    border: 1px solid rgba(255,255,255,.10);
    border-radius: 12px;
    background: rgba(255,255,255,.04);
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
  }
  .cta-inner{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    flex-wrap:wrap;
  }
  .cta-title{ font-weight:800; font-size:14px; color:#f9fafb; }
  .cta-sub{ margin-top:4px; font-size:12px; color:#9ca3af; }
  .cta-actions{ display:flex; gap:8px; flex-wrap:wrap; }
  .cta-note{ margin-top:8px; font-size:11px; color:rgba(229,231,235,.70); }

  .brand{
    max-width:1600px;
    margin:0 auto 6px;
    padding:0 18px;
  }

  /* sparkline (Chart.js) */
  .sparkline{width:100% !important; height:64px !important; display:block; margin-top:10px;}
  .card canvas.sparkline{max-width:100%;}



  /* --- Header (A案: ダッシュボードUI) --- */
  /* ===== A案：ヘッダー（ロゴ部分）だけ固定 ===== */
  .appHeader{
    position: sticky;
    top: 12px;          /* bodyのpadding:12pxに合わせる */
    z-index: 1000;      /* カードやチャートより前面に */
  }

  /* 固定時に下が透けないように（既存の背景に上書きでOK） */
  .appHeader-inner{
    backdrop-filter: blur(10px);
    background: rgba(15, 23, 42, 0.92);
  }

  .appHeader{ margin: 0 4px 12px; }
  .appHeader-inner{
    display:flex; align-items:center; justify-content:space-between; gap:12px;
    padding:10px 10px;
    border:1px solid rgba(255,255,255,.10);
    border-radius:14px;
    background:linear-gradient(180deg,rgba(255,255,255,.035),rgba(255,255,255,.015));
  }
  .appHeader-left{ display:flex; align-items:center; gap:12px; min-width:0; }
  .appHeader-right{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
  .brandLogo{ height: 26px; }
  .headerNav{ display:flex; gap:8px; flex-wrap:wrap; }
  .btn.tab{ padding:6px 12px; font-size:12px; }
  .appSubline{ margin:8px 4px 0; font-size:12px; color:#9ca3af; }

  @media (max-width: 820px){
    .appHeader-inner{ align-items:flex-start; }
    .appHeader-left{ flex-wrap:wrap; }
    .appHeader-right{ width:100%; justify-content:flex-start; }
  }
  /* セクション見出しが固定ヘッダーに隠れない対策 */
  section { scroll-margin-top: 110px; }


/* --- Fix sentiment gauge rendering (avoid conic-gradient gaps) --- */
.sent-gauge-bg, .sent-gauge-inner{ display:none !important; }
.sent-gauge{ background: none !important; width: 220px; height: 120px; }
.sent-gauge-svg{ position:absolute; left:0; top:0; width:220px; height:120px; }
.sent-gauge-needle{ bottom: 10px; height: 62px; }
.sent-gauge-center{ bottom: 6px; }

/* --- Mobile header compaction --- */
@media (max-width: 520px){
  .appHeader{ top: 8px; margin: 0 6px 10px; }
  .appHeader-inner{ padding: 8px 10px; border-radius: 14px; }
  .brandLogo{ height: 20px; }
  .appSubline{ display:none; }
  .headerNav{ flex-wrap: nowrap; overflow-x: auto; -webkit-overflow-scrolling: touch; }
  .headerNav::-webkit-scrollbar{ display:none; }
  .btn.tab{ padding: 6px 10px; font-size: 11px; }
  .appHeader-right{ gap: 6px; }
  .pill{ padding: 6px 10px; font-size: 11px; }
  #updatedPill{ display:none; }
  .btn-cta{ padding: 8px 10px; font-size: 12px; }
  /* fixed header anchor offset */
  section{ scroll-margin-top: 92px; }
}


/* ===== Side menu + compact header ===== */
:root{ --hdr-h: 64px; }
.appHeader{ position:fixed; top:0; left:0; right:0; z-index: 80; padding: 10px 0; margin:0; background: rgba(10,14,28,0.75); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(255,255,255,0.06); }
.hdr-inner{ width:100%; max-width: none; margin: 0; padding: 0 16px; display:flex; align-items:center; justify-content:space-between; gap:12px; }
.hdr-left{ display:flex; align-items:center; gap:10px; min-width:0; }
.hdr-right{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
.topNote{ max-width:1600px; margin: 6px auto 0; padding: 0 16px; color: var(--muted); font-size: 12px; }

/* header should only show logo/status/update */
.navTabs, .startBtn{ display:none !important; }

.iconBtn.menuBtn{ width:36px; height:36px; border-radius:10px; border:1px solid rgba(255,255,255,.10); background: rgba(255,255,255,.04); }
.iconBtn.menuBtn:hover{ background: rgba(255,255,255,.07); }
.burger{ position:relative; display:block; width:16px; height:2px; background:#e5e7eb; border-radius:2px; }
.burger::before,.burger::after{ content:""; position:absolute; left:0; width:16px; height:2px; background:#e5e7eb; border-radius:2px; }
.burger::before{ top:-6px; }
.burger::after{ top:6px; }

.sideMenuOverlay{ position:fixed; inset:0; background: rgba(0,0,0,.55); z-index: 90; }
.sideMenu{ position:fixed; top: calc(var(--hdr-h) + 12px); left: 12px; width: 220px;
  background: rgba(10,16,28,.92); border:1px solid rgba(255,255,255,.10); border-radius: 16px; padding: 10px; z-index: 95;
  box-shadow: 0 14px 44px rgba(0,0,0,.45); backdrop-filter: blur(10px);
}
.sideMenuHeader{ display:flex; align-items:center; justify-content:space-between; padding: 4px 4px 8px; }
.sideMenuTitle{ font-weight: 700; font-size: 13px; color:#e5e7eb; letter-spacing:.02em; }
.sideMenuNav, .sideMenuFooter{ display:flex; flex-direction:column; gap:6px; }
.sideMenuFooter{ margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,.08); }
.sideNavLink{ display:flex; align-items:center; gap:8px; padding: 9px 10px; border-radius: 12px; color:#e5e7eb; text-decoration:none; font-size: 13px; }
.sideNavLink:hover{ background: rgba(255,255,255,.06); }

/* Make sure fixed header doesn't hide anchor targets */
section[id]{ scroll-margin-top: calc(var(--hdr-h) + 16px); }

@media (max-width: 1200px){
  .sideMenu{ left: 12px; transform: translateX(-110%); transition: transform .22s ease; }
  .sideMenu.is-open{ transform: translateX(0); }
}
@media (min-width: 1201px){
  :root{ --dock-w: 252px; }
  body{ padding-left: var(--dock-w); }
  .sideMenuOverlay{ display:none !important; }
  .iconBtn.menuBtn{ display:none; }
  #menuCloseBtn{ display:none; }
  .sideMenu{ transform:none !important; opacity:1 !important; pointer-events:auto !important; }
}

@media (max-width: 640px){
  :root{ --hdr-h: 56px; }
  .brand img{ width: 34px; height: 34px; }
  .brand .title{ font-size: 14px; }
  .hdr-right{ gap:8px; }
  .statusPill, .updatedPill{ font-size: 11px; padding: 6px 8px; }
  .miniNote{ font-size:11px; padding:6px 8px; border-radius:999px; background:rgba(148,163,184,0.10); border:1px solid rgba(148,163,184,0.18); color:#cbd5e1; white-space:nowrap; }
  #refreshBtn{ padding: 7px 10px; font-size: 12px; }
}

/* sentiment gauge: we now use SVG only */
.sent-gauge::before{ display:none !important; }

/* ===== Mobile UX fixes (v40) ===== */
@media (max-width: 640px){
  /* Prevent header height jump when refresh button shows countdown */
  .hdr-right{ flex-wrap: nowrap !important; }
  #refreshBtn{ white-space: nowrap; min-width: 84px; }
  .statusPill{ white-space: nowrap; max-width: 120px; overflow: hidden; text-overflow: ellipsis; }
}

/* Section header: avoid "もっと見る" vertical wrap on narrow screens */
@media (max-width: 520px){
  .section-header{ flex-direction: column; align-items: flex-start; }
  .section-actions{ width: 100%; justify-content: flex-end; }
  .linkbtn{ white-space: nowrap; }
}

/* Sentiment gauge (SVG) must keep a positioned container */
.sent-gauge{
  position: relative !important;
  overflow: hidden !important;
}



/* ===== Quick Summary (A案) ===== */
.summary-block{ margin-top: 18px; }
.summary-kpis{
  display: grid;
  grid-template-columns: repeat(6, minmax(0, 1fr));
  gap: 12px;
  margin-top: 10px;
}

@media (max-width: 1024px){
  .summary-kpis{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
}

@media (max-width: 560px){
  .summary-kpis{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
}

@media (max-width: 820px){
  .summary-lists{ grid-template-columns: 1fr; }
}
.summary-lists{
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 12px;
  margin-top: 12px;
}

@media (max-width: 820px){
  .summary-lists{ grid-template-columns: 1fr !important; }
}
.summary-card{
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 14px;
  padding: 12px 12px 10px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.25);
}
.summary-card-title{
  font-weight: 700;
  letter-spacing: .2px;
  margin-bottom: 8px;
  color: #e5e7eb;
}
.summary-ol{
  margin: 0;
  padding: 0 0 0 18px;
}
.summary-li{
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 10px;
  padding: 6px 0;
  border-bottom: 1px solid rgba(255,255,255,0.06);
}
.summary-li:last-child{ border-bottom: 0; }
.summary-left{
  display: inline-flex;
  align-items: baseline;
  gap: 8px;
  min-width: 0;
}
.summary-rank{
  width: 22px;
  text-align: center;
  opacity: .95;
}
.summary-symbol{
  font-weight: 700;
  white-space: nowrap;
}
.summary-right{
  font-variant-numeric: tabular-nums;
  white-space: nowrap;
}
.summary-right.positive{ color: #7dd3fc; } /* existing palette-esque */
.summary-right.negative{ color: #fb7185; }
.summary-li.muted{ opacity: .75; }
.summary-li.clickable{ cursor: pointer; }
.summary-li.clickable:hover{ background: rgba(255,255,255,0.03); border-radius: 10px; padding-left: 8px; padding-right: 8px; }

/* summary is the new KPI row, so hide the old strip to avoid duplication */
#overviewKpiStrip{ display:none; }

@media (max-width: 900px){
  .summary-kpis{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
}


.summary-right-wrap{
  display:inline-flex;
  align-items:center;
  gap:10px;
  white-space:nowrap;
}
.summary-ext{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:26px;
  height:22px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.02);
  font-size: 12px;
  opacity:.9;
}
.summary-ext:hover{ background: rgba(255,255,255,0.06); }
.flash{
  outline: 2px solid rgba(125,211,252,0.9);
  outline-offset: 2px;
  animation: flashPulse 1.2s ease-in-out 0s 1;
}
@keyframes flashPulse{
  0%{ box-shadow: 0 0 0 rgba(125,211,252,0.0); }
  40%{ box-shadow: 0 0 18px rgba(125,211,252,0.45); }
  100%{ box-shadow: 0 0 0 rgba(125,211,252,0.0); }
}


  /* ===== Mini visuals for Summary KPI (v68) ===== */
  .kpi-tile{ position:relative; }
  .mini-vis{ margin-top:10px; }
  /* RSI mini bar */
  .mini-rsi-track{
    position:relative;
    height:10px;
    border-radius:999px;
    background:rgba(148,163,184,0.26);
    overflow:hidden;
    box-shadow: inset 0 0 0 1px rgba(148,163,184,0.18);
  }
  .mini-rsi-zone{ position:absolute; top:0; bottom:0; }
  .mini-rsi-zone.low{ left:0; width:30%; background:rgba(255,82,82,0.70); }
  .mini-rsi-zone.mid{ left:30%; width:40%; background:rgba(120,186,255,0.45); }
  .mini-rsi-zone.high{ left:70%; width:30%; background:rgba(72,235,142,0.62); }
  .mini-rsi-th{ position:absolute; top:0; bottom:0; width:1px; background:rgba(226,232,240,0.45); }
  .mini-rsi-th.t30{ left:30%; }
  .mini-rsi-th.t70{ left:70%; }
  .mini-rsi-marker{
    position:absolute;
    top:50%;
    width:12px; height:12px;
    border-radius:50%;
    transform:translate(-50%,-50%);
    background:rgba(226,232,240,0.98);
    box-shadow:0 0 0 3px rgba(56,189,248,0.48), 0 0 18px rgba(56,189,248,0.70);
    animation: glowPulse 2.4s ease-in-out infinite;
    left:50%;
  }

  /* Sentiment mini bar (0-100) */
  .mini-sent-track{
    position:relative;
    height:10px;
    border-radius:999px;
    background:rgba(148,163,184,0.26);
    overflow:hidden;
    box-shadow: inset 0 0 0 1px rgba(148,163,184,0.18);
  }
  .mini-sent-zone{ position:absolute; top:0; bottom:0; }
  .mini-sent-zone.fear{ left:0; width:25%; background:rgba(255,82,82,0.70); }
  .mini-sent-zone.caution{ left:25%; width:25%; background:rgba(245,158,11,0.44); }
  .mini-sent-zone.neutral{ left:50%; width:25%; background:rgba(120,186,255,0.45); }
  .mini-sent-zone.greed{ left:75%; width:25%; background:rgba(72,235,142,0.62); }
  .mini-sent-th{ position:absolute; top:0; bottom:0; width:1px; background:rgba(226,232,240,0.40); }
  .mini-sent-th.t25{ left:25%; }
  .mini-sent-th.t50{ left:50%; }
  .mini-sent-th.t75{ left:75%; }
  .mini-sent-marker{
    position:absolute;
    top:50%;
    width:12px; height:12px;
    border-radius:50%;
    transform:translate(-50%,-50%);
    background:rgba(226,232,240,0.98);
    box-shadow:0 0 0 3px rgba(56,189,248,0.46), 0 0 18px rgba(56,189,248,0.70);
    animation: glowPulse 2.4s ease-in-out infinite;
    left:50%;
  }


  /* MA cross mini bar (v79: align colors with Sentiment/RSI style) */
.mini-ma-track{
  position:relative;
  height:10px;
  border-radius:999px;
  background:rgba(148,163,184,0.26);
  overflow:hidden;
  box-shadow: inset 0 0 0 1px rgba(148,163,184,0.18);
}
.mini-ma-zone{ position:absolute; top:0; bottom:0; }
/* 左→右: 危険(DC) → 安全(GC) : 赤→黄→青→緑 */
.mini-ma-zone.dc-strong{ left:0;  width:25%; background:rgba(255,82,82,0.60); }
.mini-ma-zone.dc-weak{   left:25%; width:25%; background:rgba(245,158,11,0.44); }
.mini-ma-zone.gc-weak{   left:50%; width:25%; background:rgba(120,186,255,0.45); }
.mini-ma-zone.gc-strong{ left:75%; width:25%; background:rgba(72,235,142,0.62); }

/* 0(クロス)の基準線 */
.mini-ma-center{ position:absolute; left:50%; top:-4px; bottom:-4px; width:1px; background:rgba(226,232,240,0.26); }

.mini-ma-marker{
  position:absolute;
  top:50%;
  width:10px; height:10px;
  border-radius:50%;
  transform:translate(-50%,-50%);
  background:rgba(226,232,240,0.98);
  box-shadow:0 0 0 3px rgba(56,189,248,0.22);
}

.mini-ma-label{
  margin-top:6px;
  font-size:10px;
  line-height:1.2;
  text-align:center;
  color:rgba(229,231,235,0.60);
  letter-spacing:.2px;
  user-select:none;
}


/* Avg return mini track (centered at 0) */
.mini-avg-track{
  position:relative;
  height:10px;
  border-radius:999px;
  background: linear-gradient(90deg,
    rgba(255,82,82,0.60) 0%,
    rgba(245,158,11,0.44) 33%,
    rgba(120,186,255,0.45) 66%,
    rgba(72,235,142,0.62) 100%);
  overflow:hidden;
  box-shadow: inset 0 0 0 1px rgba(148,163,184,0.18);
}
.mini-avg-center{ position:absolute; left:50%; top:-4px; bottom:-4px; width:1px; background:rgba(226,232,240,0.22); }
.mini-avg-marker{
  position:absolute;
  top:50%;
  width:10px;
  height:10px;
  border-radius:999px;
  transform: translate(-50%, -50%);
  background: rgba(255,255,255,0.92);
  box-shadow: 0 0 0 2px rgba(11,18,32,0.9);
}
/* Dominance mini donut (SVG) */

  .mini-donut{
    width:44px; height:44px;
    display:flex;
    align-items:center;
    justify-content:center;
    opacity:0.95;
  }
  .mini-donut svg{ width:60px; height:60px; display:block; }
  .mini-donut .bg{ stroke:rgba(148,163,184,0.18); }
  .mini-donut .seg-btc{ stroke:rgba(250,204,21,0.90); }
  .mini-donut .seg-eth{ stroke:rgba(96,165,250,0.90); }
  .mini-donut .seg-stb{ stroke:rgba(52,211,153,0.85); }
  .mini-donut .seg-oth{ stroke:rgba(148,163,184,0.65); }
  .mini-donut circle{ fill:none; stroke-width:7; stroke-linecap:butt; }
  .mini-donut .rot{ transform:rotate(-90deg); transform-origin:50% 50%; }
  .kpi-with-donut{
    display:flex;
    flex-direction:column;
    align-items:stretch;
    justify-content:flex-start;
    gap: 2px;
  }
  .kpi-with-donut .kpi-text{ flex:1 1 auto; min-width:0; }
    /* Dominance mini bar (v74) */
  .mini-dom-bar{
    width:100%;
    min-width:0;
    max-width:none;
    margin-top: -4px;
    align-self:stretch;
  }
  .mini-dom-track{
    position:relative;
    height:10px;
    border-radius:999px;
    overflow:hidden;
    background:rgba(148,163,184,0.16);
    box-shadow: inset 0 0 0 1px rgba(148,163,184,0.18);
  }
  .mini-dom-seg{ position:absolute; top:0; bottom:0; left:0; width:0%; }
  .mini-dom-seg.btc{ background:rgba(250,204,21,0.90); }
  .mini-dom-seg.eth{ background:rgba(96,165,250,0.90); }
  .mini-dom-seg.stb{ background:rgba(52,211,153,0.90); }
  .mini-dom-seg.oth{ background:rgba(148,163,184,0.62); }

  .mini-dom-tick{ position:absolute; top:-8px; bottom:-8px; width:1px; background:rgba(226,232,240,0.22); }
  .mini-dom-tick span{ position:absolute; top:-16px; left:50%; transform:translateX(-50%); font-size:10px; color:rgba(203,213,225,0.72); }
  .mini-dom-tick.t50{ left:50%; }
  .mini-dom-tick.t60{ left:60%; }

  /* Avg 24h sparkline */
  .mini-spark{ height:34px; margin-top:8px; }
  .mini-spark svg{ width:100%; height:34px; display:block; }
  .mini-spark .zero{ stroke:rgba(170,190,215,0.36); stroke-width:1; }
  .mini-spark .line{ stroke:rgba(226,232,240,0.90); stroke-width:2; fill:none; }
  .mini-spark .fill{
    fill:rgba(59,130,246,0.12);
    stroke:none;
  }


@media (max-width: 720px){
  .hdr-inner{ flex-wrap: nowrap; gap: 8px; }
  .hdr-right{ flex-wrap: nowrap; gap: 8px; }
  .miniNote{ display:none; }
  .updatedPill{ max-width: 140px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .statusPill{ white-space: nowrap; }
}

/* --- Summary KPI: Breadth mini bar --- */
.kpi-mini-breadth{margin-top:10px}
.breadth-track{
  height:10px;
  border-radius:999px;
  overflow:hidden;
  background:rgba(255,255,255,0.08);
  display:flex;
}
.breadth-seg{height:100%}
.breadth-seg.up{background:rgba(52,211,153,0.85)}
.breadth-seg.down{background:rgba(248,113,113,0.85)}
.breadth-caption{margin-top:6px;font-size:10px;line-height:1.2;text-align:center;color:rgba(229,231,235,0.60);min-height:12px;letter-spacing:.2px;user-select:none}
  .meta-row {
    display: flex; justify-content: flex-end; align-items: center; gap: 5px;
    font-size: 11px; color: #9ca3af; margin-top: 3px;
    flex-wrap: wrap;
  }
  .meta-val { opacity: 0.9; white-space: nowrap; }
  .meta-badge {
    display: inline-flex;
    align-items: center;
    gap: 3px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.08);
    padding: 2px 6px; /* 少し余白を広げる */
    border-radius: 4px;
    font-size: 10px;
    white-space: nowrap;
    color: #cbd5e1; /* 文字色を少し明るく */
  }
  .card {
    cursor: pointer;
    transition: transform 0.1s ease, box-shadow 0.1s ease, background-color 0.1s;
  }
  .card:active {
    transform: scale(0.98); /* 押した時に少し縮む */
    background-color: rgba(30, 41, 59, 1); /* 少し明るくなる */
  }
  /* 画像エラー時の代替円（CSSで描画） */
  .coin-icon-fallback {
    width: 28px; height: 28px; border-radius: 50%;
    background: #334155; color: #94a3b8;
    display: flex; align-items: center; justify-content: center;
    font-size: 10px; font-weight: 700;
  }

  .skeleton {
    background: #1f2937; /* カード背景色より少し明るめ */
    border-radius: 12px;
    overflow: hidden;
    position: relative;
    pointer-events: none; /* 押せないようにする */
  }
  /* キラッと光るアニメーション */
  .skeleton::after {
    content: "";
    position: absolute; inset: 0;
    transform: translateX(-100%);
    background-image: linear-gradient(
      90deg,
      rgba(255, 255, 255, 0) 0,
      rgba(255, 255, 255, 0.03) 20%,
      rgba(255, 255, 255, 0.07) 60%,
      rgba(255, 255, 255, 0) 100%
    );
    animation: shimmer 1.5s infinite;
  }
  @keyframes shimmer {
    100% { transform: translateX(100%); }
  }

  /* スケルトン専用レイアウト */
  .sk-card {
    height: 104px; /* 本物のカードに近い高さ */
    padding: 12px;
    display: flex; flex-direction: column; justify-content: space-between;
    border: 1px solid rgba(255,255,255,0.05);
  }
  .sk-header { display: flex; align-items: center; gap: 10px; }
  .sk-circle { width: 32px; height: 32px; border-radius: 50%; background: rgba(255,255,255,0.06); }
  .sk-lines { flex: 1; display: flex; flex-direction: column; gap: 6px; }
  .sk-bar { height: 10px; border-radius: 4px; background: rgba(255,255,255,0.06); }
  .sk-w-40 { width: 40%; }
  .sk-w-30 { width: 30%; }
  .sk-w-60 { width: 60%; }
  .sk-bottom { display: flex; flex-direction: column; align-items: flex-end; gap: 6px; margin-top: 10px; }
  /* ▼▼▼ 追加：スティッキーナビゲーション（横スクロールタブ） ▼▼▼ */
  .sticky-nav {
    position: sticky;
    top: var(--hdr-h); /* ヘッダーの高さに合わせて固定 */
    z-index: 89;
    background: rgba(15, 23, 42, 0.92);
    backdrop-filter: blur(8px);
    border-bottom: 1px solid rgba(255,255,255,0.06);
    margin: 0 -12px 18px;
    padding: 8px 12px;
  }
  .sticky-nav-inner {
    display: flex; gap: 8px; overflow-x: auto;
    scrollbar-width: none;
    -webkit-overflow-scrolling: touch;
  }
  .sticky-nav-inner::-webkit-scrollbar { display: none; }

  .nav-tab {
    flex: 0 0 auto;
    display: inline-flex; align-items: center; gap: 5px;
    font-size: 11px; font-weight: 700;
    color: #94a3b8; text-decoration: none;
    padding: 6px 12px;
    border-radius: 999px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.08);
    transition: all 0.2s ease;
  }
  .nav-tab:hover, .nav-tab:active {
    color: #f9fafb;
    background: rgba(255,255,255,0.12);
    transform: translateY(-1px);
  }
  .nav-tab span { font-size: 12px; }
  /* ▼▼▼ 追加：情報表示用モーダル ▼▼▼ */
  .info-modal-overlay {
    position: fixed; inset: 0;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(4px);
    z-index: 2000;
    display: flex; align-items: center; justify-content: center;
    opacity: 0; pointer-events: none;
    transition: opacity 0.2s;
  }
  .info-modal-overlay.open { opacity: 1; pointer-events: auto; }
  
  .info-modal {
    background: #1e293b;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px;
    width: 92%; max-width: 900px;
    max-height: 80vh;
    display: flex; flex-direction: column;
    box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    transform: scale(0.95); transition: transform 0.2s;
  }
  .info-modal-overlay.open .info-modal { transform: scale(1); }

  .info-header {
    padding: 16px; border-bottom: 1px solid rgba(255,255,255,0.08);
    display: flex; justify-content: space-between; align-items: center;
  }
  .info-title { font-weight: 700; font-size: 16px; color: #f9fafb; }
  .info-close {
    background: none; border: none; color: #9ca3af; font-size: 24px; cursor: pointer; padding: 0 8px;
  }
  .info-body { padding: 20px; overflow-y: auto; font-size: 14px; line-height: 1.6; color: #cbd5e1; }
  .info-body h3 { margin: 16px 0 8px; font-size: 15px; color: #fff; }
  .info-body p { margin-bottom: 12px; }
  .info-body ul { padding-left: 20px; margin-bottom: 12px; }
  .info-body a { color: #60a5fa; text-decoration: underline; }
  /* ▼▼▼ 追加：Xシェアボタン専用スタイル ▼▼▼ */
  .linkbtn.btn-x {
    background: #000;
    border-color: #333;
    color: #fff;
    transition: border-color 0.2s;
  }
  .linkbtn.btn-x:hover {
    border-color: #ffffff; /* ホバー時は白く光る */
    background: #000;
  }
/* --- AI Insight Box: Cyber & Professional Update --- */
.ai-insight-box {
  margin: 10px 0 16px; /* 外側の余白を微減 */
  padding: 14px 18px;  /* 20px → 14px に圧縮 */
  min-height: 180px !important; /* 230px → 180px に短縮 */
  width: 100%;
  position: relative;
  overflow: hidden;

  /* 深みのあるグラデーション背景 */
  background: linear-gradient(165deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.85));
  border: 1px solid rgba(56, 189, 248, 0.35); /* 青いネオン枠 */
  border-radius: 16px;

  /* ボックス全体を優しく発光させる */
  box-shadow: 
    0 10px 25px -5px rgba(0, 0, 0, 0.5),
    0 0 15px 0 rgba(56, 189, 248, 0.12);
  backdrop-filter: blur(12px);
  transition: border-color 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
}
/* マウスを乗せた時の演出（KPIタイルと統一） */
.ai-insight-box:hover {
  /* 物理的に動かさず、色と光だけを強くする */
  border-color: rgba(56, 189, 248, 0.6) !important;
  box-shadow: 
    0 10px 30px -5px rgba(0, 0, 0, 0.6),
    0 0 25px 0 rgba(56, 189, 248, 0.25);
  background: rgba(15, 23, 42, 0.98) !important;
}
  
/* 左端のアクセント光（重要度を演出） */
.ai-insight-box::before {
  content: "";
  position: absolute;
  left: 0; top: 15%; bottom: 15%;
  width: 4px;
  background: linear-gradient(to bottom, #38bdf8, #1e88e5);
  border-radius: 0 4px 4px 0;
  box-shadow: 0 0 12px rgba(56, 189, 248, 0.6);
}

.ai-insight-header {
  display: flex; 
  align-items: center; 
  margin-bottom: 10px; /* 16px → 10px に圧縮 */
  padding-bottom: 8px;
  gap: 8px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

.ai-title-label {
  font-size: 15px; 
  font-weight: 800; 
  color: #f8fafc;
  letter-spacing: .08em;
  text-transform: uppercase;
}

.ai-badge {
  font-size: 10px; 
  padding: 3px 10px; 
  border-radius: 6px;
  background: rgba(56, 189, 248, 0.15); 
  color: #7dd3fc; 
  border: 1px solid rgba(56, 189, 248, 0.4);
  font-weight: 700;
  text-transform: uppercase;
  animation: pulse 2s infinite; /* 点滅アニメーション */
}

.ai-insight-text {
  font-size: 14px;    /* わずかに小さくして密度を上げる */
  line-height: 1.7;   /* 行間を少し詰め、垂直方向を節約 */
  min-height: 100px;  /* 140px → 100px に短縮 */
  color: #e2e8f0;
  width: 100%;
}

/* 分析文中の強調キーワード */
.ai-insight-text strong {
  color: #38bdf8; 
  font-weight: 700;
  text-shadow: 0 0 8px rgba(56, 189, 248, 0.4);
  background: rgba(56, 189, 248, 0.08);
  padding: 0 4px;
  border-radius: 4px;
}

.ai-insight-note {
  margin-top: 8px;    /* 12px → 8px に圧縮 */
  font-size: 9px;     /* 注釈をより控えめに */
  color: #64748b; 
  text-align: right;
  opacity: 0.8;
}

/* アニメーション定義 */
@keyframes spin { 100% { transform: rotate(360deg); } }
@keyframes pulse { 
  0% { opacity: 0.6; box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.2); } 
  50% { opacity: 1; box-shadow: 0 0 0 4px rgba(56, 189, 248, 0); } 
  100% { opacity: 0.6; } 
}
/* タイピングカーソルのアニメーション */
.typing::after {
  content: "▊"; /* ブロック型のカーソル */
  margin-left: 4px;
  color: #38bdf8;
  animation: blink 0.8s step-end infinite;
  vertical-align: middle;
}

@keyframes blink {
  from, to { opacity: 1; }
  50% { opacity: 0; }
}
/* ▼▼▼ 追加：時価総額テーブルのデザイン ▼▼▼ */
.table-scroll-container {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  margin: 0 -4px;
  position: relative;
  /* 右端にスクロールを促す影 */
  background: 
    linear-gradient(to left, rgb(15,23,42) 0%, rgba(15,23,42,0) 100%) 100% 0,
    radial-gradient(farthest-side at 100% 50%, rgba(0,0,0,0.4), rgba(0,0,0,0)) 100% 0;
  background-repeat: no-repeat;
  background-size: 40px 100%, 10px 100%;
  background-attachment: local, scroll;
}

.rank-table {
  width: 100%;
  border-collapse: collapse;
  min-width: 600px; /* スマホで横スクロールさせるための幅確保 */
  font-size: 13px;
}

/* ヘッダー固定 */
.rank-table th {
  position: sticky;
  top: 0;
  z-index: 10;
  background: #0f172a;
  color: #94a3b8;
  font-weight: 500;
  text-align: right;
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  white-space: nowrap;
}
.rank-table th.th-sym { text-align: left; left: 0; z-index: 11; }

/* セル設定 */
.rank-table td {
  padding: 12px;
  border-bottom: 1px solid rgba(255,255,255,0.05);
  vertical-align: middle;
  text-align: right;
  font-family: 'Inter', sans-serif;
  font-feature-settings: "tnum";
  color: #e5e7eb;
  white-space: nowrap;
}

/* 1列目（銘柄）のデザイン */
.rank-table td.td-sym {
  text-align: left;
  position: sticky;
  left: 0;
  background: #0f172a;
  z-index: 5;
  border-right: 1px solid rgba(255,255,255,0.05);
}
.sym-wrap { display: flex; align-items: center; gap: 8px; }
.sym-icon { width: 24px; height: 24px; border-radius: 50%; }
.sym-rank { color: #64748b; font-size: 11px; min-width: 16px; }
.sym-code { font-weight: 700; font-size: 13px; }

/* グラフ列のスタイル */
.rank-table th.th-chart,
.rank-table td.td-chart {
  width: 100px;
  min-width: 100px;
  padding: 4px 8px;
}
.td-chart canvas {
  width: 100% !important;
  height: 35px !important;
  display: block;
}

/* 色・バッジ */
/* ▼▼▼ 修正：詳細度を上げて、テーブル内でも確実に色がつくようにする ▼▼▼ */
.text-up, 
.rank-table td.text-up { 
  color: #4ade80; /* 上昇：緑 */
  font-weight: 600;
}

.text-down, 
.rank-table td.text-down { 
  color: #f87171; /* 下落：赤 */
  font-weight: 600;
}
/* --- 時価総額テーブル：RSIネオンバッジ（シアン連動版） --- */
.rank-table th:nth-child(6), 
.td-rsi {
  text-align: center !important;
  vertical-align: middle;
}
.rsi-badge {
  display: inline-block;
  margin: 0 auto; /* 中央配置を確実にする */
  padding: 2px 0px;
  border-radius: 6px; /* 少し角を丸めてモダンに */
  font-size: 11px;
  font-weight: 800;   /* 文字を太くして視認性アップ */
  width: 38px;
  text-align: center;
  background: rgba(15, 23, 42, 0.6); /* 背景を深くして発光を際立たせる */
  color: #64748b;
  border: 1px solid rgba(255, 255, 255, 0.05);
  transition: all 0.3s ease;
}

/* 過熱 (>70): ネオンレッド */
.rsi-high {
  background: rgba(248, 113, 113, 0.15) !important;
  color: #f87171 !important;
  border: 1px solid rgba(248, 113, 113, 0.4) !important;
  box-shadow: 0 0 10px rgba(248, 113, 113, 0.2);
  text-shadow: 0 0 5px rgba(248, 113, 113, 0.4);
}

/* 売られすぎ (<30): ネオンシアン (AIカラーと完全同期) */
.rsi-low {
  background: rgba(56, 189, 248, 0.15) !important;
  color: #38bdf8 !important; /* AIバッジと同じ色 */
  border: 1px solid rgba(56, 189, 248, 0.4) !important;
  box-shadow: 0 0 10px rgba(56, 189, 248, 0.2);
  text-shadow: 0 0 5px rgba(56, 189, 248, 0.4);
}
/* ▼▼▼ 追加：スマホ表示の最適化 ▼▼▼ */
/* ▼▼▼ 追加：スマホ表示の最適化（統合版） ▼▼▼ */
@media (max-width: 640px) {
  /* --- 1. 市場ハイライト部分のスマート化 --- */
  #sec-summary .section-header {
    flex-direction: row !important;      /* 縦並びを横並びに変更 */
    align-items: center !important;
    justify-content: space-between;
    margin-bottom: 8px;                  /* 余白を詰める */
    padding: 0 4px;
  }

  #sec-summary .section-title {
    font-size: 16px !important;
    color: #38bdf8 !important; /* AIカラーと同じ水色 */
    text-shadow: 0 0 8px rgba(56, 189, 248, 0.3);
    letter-spacing: 0.05em;
  }

  #sec-summary .section-sub {
    display: none !important;            /* スマホでは説明文を非表示にして高さを節約 */
  }

  #sec-summary .section-actions {
    width: auto !important;              /* ボタンエリアを横幅いっぱいにしない */
    margin-top: 0 !important;
    display: flex;
    gap: 6px;
  }

  #sec-summary .linkbtn {
    padding: 5px 10px !important;        /* ボタンをコンパクトに */
    font-size: 11px !important;
    height: 28px;
    display: flex;
    align-items: center;
  }

  .ai-insight-box {
    margin-top: 4px !important;          /* ボックス上の余白を最小限に */
  }

  /* --- 2. 時価総額テーブルの調整 (既存のコード) --- */
  .rank-table th, 
  .rank-table td {
    padding: 10px 4px;                   /* 余白を短縮 */
    font-size: 12px;                     /* 文字サイズを少し小さく */
  }
  
  .rank-table td.td-sym {
    padding-left: 8px;
    padding-right: 8px;
  }
  
  .sym-wrap { gap: 4px; }
  .sym-icon { width: 20px; height: 20px; }
}
/* ▼▼▼ 追加：AIセクションのガタつき防止 ▼▼▼ */
#aiInsightBox {
  /* 最初から高さを確保しておく */
  min-height: 230px; 
  /* ↑ スマホとPCの中間くらいの高さ。
     もし余白が大きすぎたら 200px くらいに調整してください */
  
  display: block !important; /* 最初から表示状態にする */
}

/* 読み込み中のプレースホルダー（中央寄せ） */
.ai-loading-placeholder {
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #64748b;
  flex-direction: column;
  gap: 10px;
  padding-top: 60px; /* 上の隙間調整 */
}
/* --- サイバー・ネオン・スピナー（小型・3D版） --- */
.cyber-loader {
  position: relative;
  width: 54px;   /* 80px → 54px に小型化 */
  height: 54px;
  display: flex;
  align-items: center;
  justify-content: center;
  perspective: 200px; /* 立体感を出すための視点 */
}

/* 外側のリング：傾きをつけて楕円に見せる */
.cyber-loader::before {
  content: "";
  position: absolute;
  width: 100%;
  height: 100%;
  border: 2px solid transparent;
  border-top: 2px solid #38bdf8;
  border-bottom: 2px solid #38bdf8;
  border-radius: 50%;
  /* 傾き（rotateX）を加えて、回転をアニメーション化 */
  transform: rotateX(60deg) rotateY(10deg);
  animation: cyber-spin-3d 1.2s linear infinite;
  box-shadow: 0 0 12px rgba(56, 189, 248, 0.4);
}

/* 内側のリング：逆方向の傾き */
.cyber-loader::after {
  content: "";
  position: absolute;
  width: 70%;
  height: 70%;
  border: 2px solid transparent;
  border-left: 2px solid #38bdf8;
  border-right: 2px solid #38bdf8;
  border-radius: 50%;
  transform: rotateX(60deg) rotateY(-30deg);
  animation: cyber-spin-3d-reverse 1.8s linear infinite;
  opacity: 0.6;
}

@keyframes cyber-spin-3d {
  0% { transform: rotateX(60deg) rotateY(10deg) rotateZ(0deg); }
  100% { transform: rotateX(60deg) rotateY(10deg) rotateZ(360deg); }
}

@keyframes cyber-spin-3d-reverse {
  0% { transform: rotateX(60deg) rotateY(-30deg) rotateZ(360deg); }
  100% { transform: rotateX(60deg) rotateY(-30deg) rotateZ(0deg); }
}
</style>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9479112166602861"
   crossorigin="anonymous"></script>
</head>
<body>
<header class="appHeader" role="banner">
<div class="hdr-inner">
<div class="hdr-left">
<button aria-controls="sideMenu" aria-expanded="false" aria-label="メニュー" class="iconBtn menuBtn" id="menuBtn" type="button">
<span aria-hidden="true" class="burger"></span>
</button>
<a aria-label="CoinRader ホーム" class="brandLink" href="/">
<img alt="CoinRader" class="brandLogo" src="/assets/coinrader_logo_horizontal_075_dark.png"/>
</a>
</div>
<div class="hdr-right">
<div class="statusPill" id="statusPill"><span class="dot"></span><span>接続中</span></div>
<div class="miniNote" id="miniNote" title="自動更新（約3分ごと）">自動3分</div>
<div class="updatedPill" id="updatedPill">更新: --</div>
<button class="btn small" id="refreshBtn" type="button">更新</button>
</div>
</div>
</header>
<nav class="sticky-nav" aria-label="クイックアクセス">
  <div class="sticky-nav-inner">
    <a href="#sec-trend" class="nav-tab" onclick="scrollToId('sec-trend'); return false;"><span>🔥</span>トレンド</a>
    <a href="#sec-gainers" class="nav-tab" onclick="scrollToId('sec-gainers'); return false;"><span>🚀</span>上昇率</a>
    <a href="#sec-volume" class="nav-tab" onclick="scrollToId('sec-volume'); return false;"><span>📊</span>出来高</a>
    <a href="#sec-alt-volume" class="nav-tab" onclick="scrollToId('sec-alt-volume'); return false;"><span>💎</span>アルト</a>
    <a href="#sec-mcap" class="nav-tab" onclick="scrollToId('sec-mcap'); return false;"><span>🏆</span>時価総額</a>
    <a href="#sec-overview" class="nav-tab" onclick="scrollToId('sec-overview'); return false;"><span>📈</span>概況</a>
  </div>
</nav>
<div class="sideMenuOverlay" hidden="" id="sideMenuOverlay"></div>
<aside aria-hidden="true" class="sideMenu" id="sideMenu">
<div class="sideMenuHeader">
<div class="sideMenuTitle">メニュー</div>
<button aria-label="閉じる" class="iconBtn" id="menuCloseBtn" type="button">×</button>
</div>
<nav aria-label="ページ内メニュー" class="sideMenuNav">
  <div style="padding:10px; font-size:12px; color:#64748b;">
    各データへのアクセスは<br>画面上部のタブが便利です。
  </div>
</nav>
<div class="sideMenuFooter">
  <a class="sideNavLink" href="#" onclick="openPageModal('start.html', '🔰 始め方'); return false;">🔰 始め方</a>
  <a class="sideNavLink" href="#" onclick="openPageModal('about.html', 'ℹ️ 運営者情報'); return false;">ℹ️ 運営者情報</a>
  <a class="sideNavLink" href="#" onclick="openPageModal('disclaimer.html', '⚠️ 免責事項'); return false;">⚠️ 免責事項</a>
  <a class="sideNavLink" href="#" onclick="openPageModal('data-sources.html', '📊 データソース'); return false;">📊 データソース</a>
  <a class="sideNavLink" href="#" onclick="openPageModal('ads-pr.html', '📢 広告・PR表記'); return false;">📢 広告・PR表記</a>
  <a class="sideNavLink" href="#" onclick="openPageModal('privacy.html', '🔒 プライバシーポリシー'); return false;">🔒 プライバシーポリシー</a>
  <a class="sideNavLink" href="#" onclick="openPageModal('contact.html', '📩 お問い合わせ'); return false;">📩 お問い合わせ</a>
</div>
</aside>
<section aria-label="今日の注目" class="summary-block" id="sec-summary">
<div class="section-header">
<div>
<div class="section-title">⚡️ リアルタイム・マーケット解析</div>
</div>
<div class="section-actions">
  <button class="linkbtn btn-x" onclick="shareMarketStatus()" style="margin-right:4px;">
    <span style="font-size:11px">𝕏</span> 共有
  </button>
  <a class="linkbtn" href="#sec-overview" onclick="scrollToId('sec-overview'); return false;">市場概況</a>
</div>
</div>
<div class="ai-insight-box" id="aiInsightBox">
  <div class="ai-insight-header">
    <span style="font-size:18px; margin-right:2px;">🤖</span>
    <span class="ai-title-label">AI Market Insight</span>
    <span class="ai-badge">Beta</span>
    <span id="aiUpdateTime" style="margin-left: auto; font-size: 10px; color: #38bdf8; font-family: monospace; opacity: 0.6; letter-spacing: 1px;">[ STANDBY ]</span>
  </div>

<div class="ai-insight-text" id="aiInsightText">
  <div class="ai-loading-placeholder" style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:140px; width:100%; gap:15px;">
    <div class="cyber-loader">
      <div class="cyber-dot"></div>
    </div>
    <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
      <span style="font-family:monospace; color:#38bdf8; font-size:10px; opacity:0.9; letter-spacing:2px; animation: pulse 1.5s infinite;">SYSTEM.ANALYZING...</span>
      <span style="color:#64748b; font-size:11px; font-weight:500;">市場構造をスキャン中</span>
    </div>
  </div>
</div>
  
  <div class="ai-insight-note">※指標に基づく自動生成コメントです。投資助言ではありません。</div>
</div>
<div class="summary-kpis" id="summaryKpis">

  <div class="kpi-tile kpi-sent">
    <div class="kpi-tile-title">恐怖指数（0–100）</div>
    <div class="kpi-value-row"><div class="kpi-tile-big" id="sumSentMain">-</div><div class="kpi-tile-sub inline" id="sumSentSub">-</div></div>
    <div aria-hidden="true" class="mini-vis">
      <div class="mini-sent-track">
        <div class="mini-sent-zone fear"></div>
        <div class="mini-sent-zone caution"></div>
        <div class="mini-sent-zone neutral"></div>
        <div class="mini-sent-zone greed"></div>
        <div class="mini-sent-th t25"></div>
        <div class="mini-sent-th t50"></div>
        <div class="mini-sent-th t75"></div>
        <div class="mini-sent-marker" id="sumSentMarker"></div>
      </div>
      <div class="kpi-bar-caption">恐怖 ← 50 → 強欲</div>
    </div>
  </div>
  <div class="kpi-tile kpi-rsi">
    <div class="kpi-tile-title">BTC RSI（14）</div>
    <div class="kpi-value-row"><div class="kpi-tile-big" id="sumRsiMain">-</div><div class="kpi-tile-sub inline" id="sumRsiSub">-</div></div>
    <div aria-hidden="true" class="mini-vis">
      <div class="mini-rsi-track">
        <div class="mini-rsi-zone low"></div>
        <div class="mini-rsi-zone mid"></div>
        <div class="mini-rsi-zone high"></div>
        <div class="mini-rsi-th t30"></div>
        <div class="mini-rsi-th t70"></div>
        <div class="mini-rsi-marker" id="sumRsiMarker"></div>
      </div>
      <div class="kpi-bar-caption">売られすぎ ← 50 → 買われすぎ</div>
    </div>
  </div>

  <div class="kpi-tile kpi-breadth">
    <div class="kpi-tile-title">上昇 / 下落 銘柄数（24h）</div>
    <div class="kpi-value-row"><div class="kpi-tile-big" id="sumBreadthMain">-</div><div class="kpi-tile-sub inline" id="sumBreadthSub">-</div></div>
    <div class="kpi-mini-breadth mini-vis" title="上位250の24h上昇/下落銘柄数">
      <div aria-hidden="true" class="breadth-track">
        <div class="breadth-seg up" id="sumBreadthSegUp"></div>
        <div class="breadth-seg down" id="sumBreadthSegDown"></div>
      </div>
      <div class="breadth-caption kpi-bar-caption" id="sumBreadthCaption">上昇/下落（24h）</div>
    </div>
  </div>

  <div class="kpi-tile kpi-dom">
    <div class="kpi-tile-title">BTC ドミナンス</div>
    <div class="kpi-with-donut">
      <div class="kpi-text">
        <div class="kpi-value-row"><div class="kpi-tile-big" id="sumDomMain">-</div><div class="kpi-tile-sub inline" id="sumDomSub">-</div></div>
      </div>
      <div aria-hidden="true" class="mini-dom-bar mini-vis" title="BTC/ETH/ステーブル/Others 構成">
        <div aria-label="Dominance bar" class="mini-dom-track" role="img">
          <div class="mini-dom-seg btc" id="sumDomSegBtc"></div>
          <div class="mini-dom-seg eth" id="sumDomSegEth"></div>
          <div class="mini-dom-seg stb" id="sumDomSegStb"></div>
          <div class="mini-dom-seg oth" id="sumDomSegOth"></div>
          <div class="mini-dom-tick t50"><span>50</span></div>
          <div class="mini-dom-tick t60"><span>60</span></div>
        </div>
        <div class="kpi-bar-caption">BTC / ETH / ステーブル / その他</div>
      </div>
    </div>
  </div>

  <div class="kpi-tile kpi-ma">
    <div class="kpi-tile-title">BTC MAクロス距離（50/200）</div>
    <div class="kpi-value-row"><div class="kpi-tile-big" id="sumMaMain">-</div><div class="kpi-tile-sub inline" id="sumMaSub">-</div></div>
    <div aria-hidden="true" class="mini-vis" title="SMA50とSMA200の乖離（%）。0に近いほどクロスが近い。左=下(マイナス) / 右=上(プラス)。">
      <div class="mini-ma-track">
        <div class="mini-ma-zone dc-strong"></div>
        <div class="mini-ma-zone dc-weak"></div>
        <div class="mini-ma-zone gc-weak"></div>
        <div class="mini-ma-zone gc-strong"></div>
        <div class="mini-ma-center"></div>
        <div class="mini-ma-marker" id="sumMaMarker"></div>
      </div>
      <div class="mini-ma-label kpi-bar-caption">下 ← 0 → 上</div>
    </div>
  </div>

<div class="kpi-tile kpi-vol">
  <div class="kpi-tile-title">市場出来高 (24h)</div>
  <div class="kpi-value-row">
    <div class="kpi-tile-big" id="kpiStripVolMain">-</div>
    <div class="kpi-tile-sub inline" id="kpiStripVolSub">-</div>
  </div>
  <div class="mini-vis" style="margin-top:10px;">
    <div style="display:flex; height:6px; border-radius:99px; overflow:hidden; background:rgba(255,255,255,0.1);">
      <div id="miniVolBarBtc" style="background:#facc15; width:0%"></div>
      <div id="miniVolBarEth" style="background:#60a5fa; width:0%"></div>
      <div id="miniVolBarOth" style="background:#9ca3af; width:0%"></div>
    </div>
    <div class="kpi-bar-caption">BTC / ETH / Others</div>
  </div>
</div>
</div>
  
</div></div></div>
<div class="summary-lists">
<div class="summary-card">
<div class="summary-card-title">🔥 トレンド TOP5</div>
<ol class="summary-ol" id="summaryTrendList"><li class="summary-li muted">データ取得中…</li></ol>
</div>
<div class="summary-card">
<div class="summary-card-title">🚀 上昇 TOP5（24h）</div>
<ol class="summary-ol" id="summaryUpList"><li class="summary-li muted">データ取得中…</li></ol>
</div>
<div class="summary-card">
<div class="summary-card-title">📊 出来高(アルト) TOP5（24h）</div>
<ol class="summary-ol" id="summaryVolAltList"><li class="summary-li muted">データ取得中…</li></ol>
</div>
</div>
</section>
<section aria-label="おすすめ取引所導線" class="cta-block">
<div class="cta-inner">
<div class="cta-text">
<div class="cta-title">取引所おすすめ（広告・PR）</div>
<div class="cta-sub">国内取引所を用途別に比較。公式サイト/キャンペーン導線をまとめています。</div>
</div>
<div class="cta-actions">
<a class="btn primary" data-cta="top_to_adspr" data-partner="" data-placement="index_cta_block" data-pr="0" href="/ads-pr">取引所おすすめを見る</a>
</div>
</div>
<div class="cta-note">※当サイトは一部リンクにアフィリエイト広告を含みます。</div>
</section>

  <div style="margin: 0 4px 14px; padding: 10px 14px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.08); border-radius: 10px; font-size: 11px; color: #9ca3af; line-height: 1.5;">
    <div style="font-weight: 700; color: #cbd5e1; margin-bottom: 4px; display: flex; align-items: center; gap: 4px;">
      <span>💡</span> 指標の解説：回転率・ATH比
    </div>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;">
      <div><strong>回転率：</strong> 24h出来高÷時価総額。値が高いほど短期売買が活発。</div>
      <div><strong>ATH比：</strong> 過去最高値(ATH)からの乖離。マイナスが大きいほど底値圏。</div>
    </div>
    <div style="margin-top: 6px; font-size: 10px; color: #64748b; border-top: 1px solid rgba(255,255,255,0.05); padding-top: 4px;">
      ※上場直後の銘柄や、APIの提供データに欠損がある場合は表示されません。
    </div>
  </div>
<section id="sec-trend">
<div class="section-header">
<div>
<div class="section-title">トレンド TOP5</div>
<div class="section-sub">CoinGeckoの「トップトレンド」（API: /search/trending）／カード内チャート：過去7日スパークライン（サンプル間隔・点数はAPI依存）</div>
</div>
<div class="section-actions">
<a class="linkbtn" data-ga="ext_coingecko_trending" data-partner="coingecko" data-placement="index_trend_header" data-pr="0" href="https://www.coingecko.com/ja/highlights/trending-crypto" rel="noopener" target="_blank">もっと見る</a>
</div>
</div>
<div class="grid" id="grid-trend"><div class="msg">データ取得中…</div></div>
</section>
<section id="sec-gainers">
<div class="section-header">
<div>
<div class="section-title">上昇率 TOP5</div>
<div class="section-sub">ステーブル除外＋24h出来高5億円以上を優先した24h騰落率TOP5（時価総額上位250銘柄から抽出）／カード内チャート：過去24時間（1d）（サンプル間隔・点数はAPI依存）</div>
</div>
<div class="section-actions">
<a class="linkbtn" data-ga="ext_coingecko_gainers" data-partner="coingecko" data-placement="index_gainers_header" data-pr="0" href="https://www.coingecko.com/ja/crypto-gainers-losers" rel="noopener" target="_blank">もっと見る</a>
</div>
</div>
<div class="grid" id="grid-gainers"><div class="msg">データ取得中…</div></div>
</section>
<section id="sec-volume">
<div class="section-header">
<div>
<div class="section-title">出来高 TOP5</div>
<div class="section-sub">24h出来高TOP5（全体：BTC/ETH/ステーブル含む／時価総額上位250銘柄から抽出）／カード内チャート：過去24時間（1d）（サンプル間隔・点数はAPI依存）</div>
</div>
<div class="section-actions">
<a class="linkbtn" data-ga="ext_coingecko_high_volume" data-partner="coingecko" data-placement="index_volume_header" data-pr="0" href="https://www.coingecko.com/ja/highlights/high-volume" rel="noopener" target="_blank">もっと見る</a>
</div>
</div>
<div class="grid" id="grid-volume"><div class="msg">データ取得中…</div></div>
</section>
<section id="sec-alt-volume">
<div class="section-header">
<div>
<div class="section-title">出来高（アルト）TOP5</div>
<div class="section-sub">BTC/ETH/ステーブルを除外した24h出来高TOP5（時価総額上位250銘柄から抽出）／カード内チャート：過去24時間（1d）（サンプル間隔・点数はAPI依存）</div>
</div>
<div class="section-actions">
<a class="linkbtn" data-ga="ext_coingecko_high_volume_alt" data-partner="coingecko" data-placement="index_alt_volume_header" data-pr="0" href="https://www.coingecko.com/ja/highlights/high-volume" rel="noopener" target="_blank">もっと見る</a>
</div>
</div>
<div class="grid" id="grid-alt-volume"><div class="msg">データ取得中…</div></div>
</section>
<section id="sec-mcap">
<div class="section-header">
<div>
<div class="section-title">時価総額 TOP20</div>
<div class="section-sub">時価総額上位20銘柄の市場状況一覧</div>
</div>
<div class="section-actions">
<a class="linkbtn" data-ga="ext_coingecko_home" data-partner="coingecko" data-placement="index_mcap_header" data-pr="0" href="https://www.coingecko.com/ja" rel="noopener" target="_blank">もっと見る</a>
</div>
</div>

<div class="table-scroll-container">
  <table class="rank-table" id="mcapTable">
    <thead>
      <tr>
        <th class="th-sym">銘柄</th>
        <th class="th-price">現在値</th>
        <th class="th-chg">前日比</th> <th class="th-chg">7日比</th>  <th class="th-mcap">時価総額</th> <th class="th-rsi">RSI</th>
        <th class="th-chart">7d推移</th>
        <th class="th-vol">24h出来高</th>
      </tr>
    </thead>
    <tbody id="mcapTableBody">
      </tbody>
  </table>
</div>
</section>
<section id="sec-overview">
<div class="section-header">
<div>
<div class="section-title">市場概況</div>
<div class="section-sub">※追加APIなし：時価総額上位250（JPY）から算出した概況</div>
</div>
<div class="section-actions">
  <button class="linkbtn" id="btnOverviewToggle" type="button">詳細</button>
  <a class="linkbtn" data-ga="ext_coingecko_home" data-partner="coingecko" data-placement="index_overview_header" data-pr="0" href="https://www.coingecko.com" rel="noopener" target="_blank">もっと見る</a>
</div>
</div>
<div class="overview-kpi-strip" id="overviewKpiStrip">
<div class="kpi-tile">
<div class="kpi-tile-title">時価総額（上位250 / JPY）</div>
<div class="kpi-tile-big" id="kpiStripMcapMain">-</div>
<div class="kpi-tile-sub" id="kpiStripMcapSub">-</div>
</div>
<div class="kpi-tile">
<div class="kpi-tile-title">Dominance（上位250）</div>
<div class="kpi-tile-big" id="kpiStripDomMain">-</div>
<div class="kpi-tile-sub" id="kpiStripDomSub">-</div>
</div>
<div class="kpi-tile">
<div class="kpi-tile-title">市場の上昇下落（24h）</div>
<div class="kpi-tile-big" id="kpiStripBreadthMain">-</div>
<div class="kpi-tile-sub" id="kpiStripBreadthSub">-</div>
</div>
<div class="kpi-tile">
<div class="kpi-tile-title">平均 / 中央値（7d）</div>
<div class="kpi-tile-big" id="kpiStripAvgMain">-</div>
<div class="kpi-tile-sub" id="kpiStripAvgSub">-</div>
</div>
<div class="kpi-tile">
<div class="kpi-tile-title">BTC RSI（14 / 7d）</div>
<div class="kpi-tile-big" id="kpiStripRsiMain">-</div>
<div class="kpi-tile-sub" id="kpiStripRsiSub">-</div>
</div>
<div class="kpi-tile">
<div class="kpi-tile-title">CoinRader Sentiment（0–100）</div>
<div class="kpi-tile-big" id="kpiStripSentMain">-</div>
<div class="kpi-tile-sub" id="kpiStripSentSub">-</div>
</div>
</div>
<div class="overview is-collapsed" id="overviewWrap">
  
  <div class="overview-card">
    <div style="font-size:13px; font-weight:700; color:#e5e7eb; margin-bottom:8px;">資金シェア (Dominance)</div>
    <div class="donut-wrap"><canvas id="domChart"></canvas></div>
    <div class="dom-metrics" id="domMetrics">-</div>
    <div class="overview-note">市場の資金が「どこに集中しているか」の比率。BTCが高いと守りの相場、ETHやOthersが高いと攻めの相場。</div>
  </div>

  <div class="overview-card">
    <div class="kpi-grid">
      
      <div class="kpi" id="kpiBreadthCard">
        <div class="kpi-label">騰落銘柄数 (7日間累積)</div>
        <div class="kpi-value" id="kpiBreadth">-</div>
        <div class="kpi-meta" id="kpiBreadthNow">-</div>
        <div class="kpi-meta" id="kpiBreadthMoves">-</div>
        <div class="kpi-sub" id="kpiBreadthSub">過去7日間で「上がった銘柄」と「下がった銘柄」の累積差。市場の地合い（強さ）を示します。</div>
        <canvas class="kpi-canvas tall" id="breadthLine"></canvas>
      </div>

      <div class="kpi">
        <div class="kpi-label">平均パフォーマンス (7日間)</div>
        <div class="kpi-value" id="kpiAvgChange">-</div>
        <div class="kpi-meta" id="kpiAvgDist">-</div>
        <div class="kpi-sub" id="kpiAvgSub">主要250銘柄の平均的なリターン推移。0%より上なら、適当に買っても利益が出やすい状態です。</div>
        <canvas class="kpi-canvas" id="avgLine"></canvas>
      </div>

      <div class="kpi">
        <div class="kpi-label">BTC RSI (過熱感 / 7日間)</div>
        <div class="kpi-value" id="kpiRsi">-</div>
        <div class="kpi-meta" id="kpiRsiMeta">-</div>
        <div class="kpi-sub" id="kpiRsiSub">買われすぎ(70↑)・売られすぎ(30↓)を判断。天井や底打ちのサインとして機能します。</div>
        <div class="rsi-chart-wrap">
          <div class="rsi-chart-area">
            <div class="rsi-th rsi-70" aria-hidden="true"></div>
            <div class="rsi-th rsi-30" aria-hidden="true"></div>
            <canvas class="kpi-canvas" id="rsiLine"></canvas>
          </div>
        </div>
      </div>

      <div class="kpi">
        <div class="kpi-label">市場センチメント (投資家心理)</div>
        <div class="kpi-value" id="kpiSentiment">-</div>
        <div class="kpi-meta" id="kpiSentimentMeta">-</div>
        <div class="kpi-sub">複数の指標から算出した「市場のムード」。数値が高いと楽観(強欲)、低いと悲観(恐怖)を表します。</div>
        <canvas class="kpi-canvas tiny" id="sentLine"></canvas>
      </div>

      <div class="kpi kpi-stack">
        <div class="kpi-label">資金フロー (時価総額 & 出来高)</div>

        <div class="kpi-block">
          <div class="kpi-block-title">市場時価総額 (Money In/Out)</div>
          <div class="kpi-value" id="kpiTotalMcap">-</div>
          <div class="kpi-meta" id="kpiMcap7d">-</div>
          <canvas class="kpi-canvas" id="mcap7dLine"></canvas>
          <div class="kpi-sub" style="opacity:.75;margin-top:6px;">市場全体のパイの大きさの推移。</div>
        </div>
      </div>
      
    </div>
  </div>
</div>


<div class="overview-note">※推移グラフは追加APIなしで作るため、上位250の「7日スパークライン」等から概算しています（目安）。</div>
</div>
</div>
<div class="msg" id="overviewMsg" style="display:none"></div>
</section>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  if (typeof Chart !== "undefined" && Chart.registerables) { Chart.register.apply(null, Chart.registerables); }

  // ============ CoinGecko API Key（運営者用）===========
  // 公開サイトでは入力欄を出さない方がUXが良いため、キーはここに固定してください。
  // 例: const COINGECKO_API_KEY = 'CG-xxxxxxxxxxxxxxxx';
  // ※このHTMLは閲覧者にも見えるため、将来的にはWorkersプロキシでキーを隠すのが推奨です。
  const COINGECKO_API_KEY = '';

  // ============ Refresh / Rate-limit friendly ============
  const REFRESH_COOLDOWN_MS = 60 * 1000; // 60s
  let lastRefreshAt = 0;
  let refreshTimer = null;
  const refreshBtn = document.getElementById('refreshBtn');

  // Keep CSS var --hdr-h in sync with the actual header height (mobile: prevents top note being covered)
  function syncHeaderHeight(){
    try{
      const hdr = document.querySelector('.appHeader');
      if(!hdr) return;
      const h = Math.max(48, Math.ceil(hdr.getBoundingClientRect().height));
      document.documentElement.style.setProperty('--hdr-h', h + 'px');
    }catch(_e){}
  }


  function setStatus(text){ document.getElementById('statusPill').textContent = '状態: ' + text; }

  // --- Updated time pill (stay on page -> time keeps moving) ---
  function formatAgo(ts){
    if(!ts) return '';
    const d = Date.now() - ts;
    if (d < 10 * 1000) return 'たった今';
    if (d < 60 * 1000) return `${Math.floor(d/1000)}秒前`;
    if (d < 60 * 60 * 1000) return `${Math.floor(d/60000)}分前`;
    if (d < 24 * 60 * 60 * 1000) return `${Math.floor(d/3600000)}時間前`;
    return `${Math.floor(d/86400000)}日前`;
  }

  function renderUpdatedPill(){
    const el = document.getElementById('updatedPill');
    if(!el) return;
    const ts = getLastFetchAt();
    if(!ts){
      el.textContent = '更新: --';
      return;
    }
    const dt = new Date(ts);
    const ago = formatAgo(ts);
    el.textContent = '更新: ' + dt.toLocaleString('ja-JP', { hour12:false }) + (ago ? `（${ago}）` : '');
  }

  function setUpdated(){
    // 互換用：今後は localStorage(lastFetch) を基準に表示する
    renderUpdatedPill();
  }

  function startUpdatedTicker(){
    renderUpdatedPill();
    setInterval(renderUpdatedPill, 1000);
  }

  
  // --- Auto refresh (every 3 min when tab is visible) ---
  const AUTO_REFRESH_MS = 3 * 60 * 1000;
  function startAutoRefresh(){
    let autoMs = 3 * 60 * 1000; // base 3min
    let failStreak = 0;

    const schedule = (delay) => {
      setTimeout(async () => {
        try{
          if (document.visibilityState !== 'visible'){
            schedule(autoMs);
            return;
          }

          IN_AUTO_REFRESH = true;
          await refreshData();
          IN_AUTO_REFRESH = false;

          if (LAST_HTTP_STATUS === 200){
            failStreak = 0;
            autoMs = 3 * 60 * 1000;
          } else if (LAST_HTTP_STATUS === 429 || LAST_HTTP_STATUS === 403){
            failStreak++;
            autoMs = Math.min(30 * 60 * 1000, 5 * 60 * 1000 * (2 ** Math.min(failStreak-1, 3))); // 5,10,20,30min
            setStatus('取得が混み合っています（保存済みデータを表示中）');
          } else if (LAST_HTTP_STATUS && LAST_HTTP_STATUS !== 200){
            failStreak++;
            autoMs = Math.min(15 * 60 * 1000, 3 * 60 * 1000 * (2 ** Math.min(failStreak, 3))); // 3,6,12,15min
            setStatus('最新データの取得が遅れています（保存済みデータを表示中）');
          } else {
            failStreak = 0;
            autoMs = 3 * 60 * 1000;
          }
        }catch(e){
          IN_AUTO_REFRESH = false;
          failStreak++;
          autoMs = Math.min(15 * 60 * 1000, 3 * 60 * 1000 * (2 ** Math.min(failStreak, 3)));
          setStatus('最新データの取得が遅れています（保存済みデータを表示中）');
        }finally{
          schedule(autoMs);
        }
      }, delay);
    };

    schedule(autoMs);
  }

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

// ============ Local cache (F5連打対策) ============
const CACHE_TTL_MS = 5 * 60 * 1000;            // 5分はキャッシュを優先表示
const BOOT_NETWORK_COOLDOWN_MS = 25 * 1000;    // 25秒以内の再読み込みはネット取得をスキップ（API制限対策）
const LS_KEYS = {
  markets: "cg_marketsTop250_jpy_v1",
  trendingIds: "cg_trendingTop5_ids_v1",
  trendingSnapshot: "cg_trendingTop5_snapshot_v1",
  gainersSnapshot: "cg_gainersTop5_snapshot_v4",
  volumeSnapshot: "cg_volumeTop5_snapshot_v3",
  altVolumeSnapshot: "cg_altVolumeTop5_snapshot_v1",
  mcapSnapshot: "cg_mcapTop20_snapshot_v2",
  lastFetch: "cg_last_fetch_at_v1",
  lastAttempt: "cg_last_attempt_at_v1"
};

function lsGet(key){
  try { return localStorage.getItem(key); } catch { return null; }
}
function lsSet(key, val){
  try { localStorage.setItem(key, val); } catch {}
}
function readCache(key){
  const raw = lsGet(key);
  if (!raw) return null;
  try { return JSON.parse(raw); } catch { return null; }
}
function writeCache(key, data){
  lsSet(key, JSON.stringify({ ts: Date.now(), data }));
}
function getLastFetchAt(){
  const v = Number(lsGet(LS_KEYS.lastFetch) || "0");
  return Number.isFinite(v) ? v : 0;
}
function setLastFetchAt(){
  lsSet(LS_KEYS.lastFetch, String(Date.now()));
  try{ renderUpdatedPill(); }catch(e){}
}

function getLastAttemptAt(){
  const v = Number(lsGet(LS_KEYS.lastAttempt) || "0");
  return Number.isFinite(v) ? v : 0;
}
function setLastAttemptAt(){
  lsSet(LS_KEYS.lastAttempt, String(Date.now()));
  try{ renderUpdatedPill(); }catch(e){}
}


function coinSnapshot(c){
  if(!c) return null;
  const sp = c.sparkline_in_7d && Array.isArray(c.sparkline_in_7d.price) ? c.sparkline_in_7d.price : null;
  const spTrim = sp ? sp.filter(v => typeof v === 'number' && Number.isFinite(v)).slice(-240) : null;
  return {
    id: c.id,
    name: c.name,
    symbol: c.symbol,
    image: c.image,
    market_cap_rank: c.market_cap_rank ?? null,
    current_price: (typeof c.current_price === 'number' && Number.isFinite(c.current_price)) ? c.current_price : null,
    market_cap: (typeof c.market_cap === 'number' && Number.isFinite(c.market_cap)) ? c.market_cap : null,
    total_volume: (typeof c.total_volume === 'number' && Number.isFinite(c.total_volume)) ? c.total_volume : null,
    price_change_percentage_24h: (typeof c.price_change_percentage_24h === 'number' && Number.isFinite(c.price_change_percentage_24h)) ? c.price_change_percentage_24h : null,
    sparkline_in_7d: spTrim ? { price: spTrim } : undefined,
  };
}

function writeSnapshot(key, coins){
  try{
    const snap = (coins || []).slice(0,5).map(coinSnapshot).filter(Boolean);
    writeCache(key, snap);
  }catch(e){}
}

function normalizeSnapshotCoin(c){
  if (!c || typeof c !== 'object') return c;
  // Backward compatibility: older cached snapshots stored sparkline as `sparkline_in_7d_price` (array)
  // or `sparkline_in_7d` directly as an array.
  if (!c.sparkline_in_7d) {
    if (Array.isArray(c.sparkline_in_7d_price)) c.sparkline_in_7d = { price: c.sparkline_in_7d_price };
    else if (Array.isArray(c.sparkline)) c.sparkline_in_7d = { price: c.sparkline };
    else if (Array.isArray(c.sparkline_in_7d)) c.sparkline_in_7d = { price: c.sparkline_in_7d };
  } else if (Array.isArray(c.sparkline_in_7d)) {
    c.sparkline_in_7d = { price: c.sparkline_in_7d };
  }
  return c;
}

function readSnapshot(key){
  const cached = readCache(key);
  const snap = (cached && Array.isArray(cached.data)) ? cached.data : null;
  return Array.isArray(snap) ? snap.map(normalizeSnapshotCoin) : [];
}


  function tickRefreshButton(){
    const now = Date.now();
    const remain = Math.max(0, (lastRefreshAt + REFRESH_COOLDOWN_MS) - now);
    if (remain > 0){
      refreshBtn.disabled = true;
      refreshBtn.textContent = `更新（${Math.ceil(remain/1000)}s）`;
    } else {
      refreshBtn.disabled = false;
      refreshBtn.textContent = '更新';
    }
    // header height can change slightly on narrow screens when the button label updates
    try{ syncHeaderHeight(); }catch(_e){}}

  function markRefreshed(){
    lastRefreshAt = Date.now();
    if (refreshTimer) clearInterval(refreshTimer);
    refreshTimer = setInterval(tickRefreshButton, 250);
    tickRefreshButton();
  }

  async function refreshData(){
    const now = Date.now();
    if (now < lastRefreshAt + REFRESH_COOLDOWN_MS){
      tickRefreshButton();
      setStatus('更新待機');
      return;
    }
    setLastAttemptAt();
    await init(true);
  }

  function scrollToId(id){
    // if user navigates to Market Overview, auto-expand the detail charts
    if (id === 'sec-overview'){
      try{
        if (window.__setOverviewOpen) window.__setOverviewOpen(true);
        else {
          const ow = document.getElementById('overviewWrap');
          if (ow) ow.classList.remove('is-collapsed');
          setTimeout(()=>{ try{ renderOverview();
    renderQuickSummary(); }catch(_e){} }, 30);
        }
      }catch(_e){}
    }

    const el = document.getElementById(id);
    if (el) el.scrollIntoView({ behavior:'smooth', block:'start' });
  }

  // ============ Fetch helpers ============
  async function cgFetch(url, options = {}){
    const headers = { ...(options.headers || {}) };
    if (COINGECKO_API_KEY) headers['x-cg-demo-api-key'] = COINGECKO_API_KEY;
    return fetch(url, { ...options, headers });
  }

  async function fetchWithTimeout(url, timeoutMs = 15000, options = {}){
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try{
      return await cgFetch(url, { ...options, signal: controller.signal });
    } finally {
      clearTimeout(timer);
    }
  }

  // 429/5xx を少しだけリトライ（Retry-After対応）
  let LAST_HTTP_STATUS = 0;
let LAST_FETCH_ERROR = '';
let IN_AUTO_REFRESH = false;
async function fetchJsonRetry(url, {timeoutMs=15000, retries=2} = {}){
    let lastErr = null;
    for (let attempt=0; attempt<=retries; attempt++){
      try{
        const res = await fetchWithTimeout(url, timeoutMs);
        if (res.ok) return await res.json();

        let bodyText = '';
        try{ bodyText = await res.text(); }catch(e){}
        console.warn('API not ok:', res.status, url, bodyText.slice(0,200));

        if (res.status === 429 || (res.status >= 500 && res.status <= 599)){
          // Retry-After があれば尊重
          if (attempt < retries){
            const ra = res.headers.get('retry-after');
            const waitMs = ra ? (parseInt(ra,10) * 1000) : (600 * (attempt+1));
            await sleep(Math.min(waitMs, 5000));
            continue;
          }
        }

        throw new Error(`HTTP ${res.status}`);

      } catch(e){
        lastErr = e;
        if (attempt < retries){
          await sleep(500 * (attempt+1));
          continue;
        }
      }
    }
    throw lastErr || new Error('fetch failed');
  }

// ▼▼▼ 修正版：価格フォーマット関数（小額通貨対応） ▼▼▼
function yen(n){
  if (typeof n !== 'number') return '-';
  if (n === 0) return '¥0';

  // 1. 1000円以上 -> 整数 (例: ¥1,234,567)
  // BTCやETHなど。細かい小数はノイズになるのでカット
  if (n >= 1000) {
    return n.toLocaleString('ja-JP', { style:'currency', currency:'JPY', maximumFractionDigits: 0 });
  }

  // 2. 50円以上 -> 小数1桁 (例: ¥150.5)
  // XRP, ADAなど。
  if (n >= 50) {
    return n.toLocaleString('ja-JP', { style:'currency', currency:'JPY', minimumFractionDigits: 1, maximumFractionDigits: 1 });
  }

  // 3. 1円以上 -> 小数2桁 (例: ¥15.35)
  // DOGE, TRXなど。
  if (n >= 1) {
    return n.toLocaleString('ja-JP', { style:'currency', currency:'JPY', minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  // 4. 1円未満 (0.0001円以上) -> 小数4桁 (例: ¥0.0025)
  // ミームコインなどで重要な帯域
  if (n >= 0.0001) {
    return '¥' + n.toFixed(4);
  }

  // 5. 極小額 (0.0001円未満) -> 最大8桁 (例: ¥0.00001234)
  // PEPEやBONKなど。末尾の不要な0は削除してスッキリさせる
  return '¥' + n.toFixed(8).replace(/\.?0+$/, "");
}
  // ★追加：大きな数値用（時価総額・出来高用：万・億・兆）
  function yenLarge(n){
    if (typeof n !== 'number') return '-';
    if (n === 0) return '¥0';
    
    // 1兆以上
    if (Math.abs(n) >= 1_000_000_000_000) {
      return '¥' + (n / 1_000_000_000_000).toFixed(2) + '兆';
    }
    // 1億以上
    if (Math.abs(n) >= 100_000_000) {
      return '¥' + (n / 100_000_000).toFixed(1) + '億'; // 億は小数点1桁で見やすく
    }
    // 1万以上
    if (Math.abs(n) >= 10_000) {
      return '¥' + (n / 10_000).toFixed(0) + '万';
    }
    
    // それ未満は通常の円表記
    return yen(n);
  }
  function yenSigned(n){
    if (typeof n !== 'number' || !isFinite(n)) return '-';
    const sign = n > 0 ? '+' : (n < 0 ? '-' : '');
    const abs = Math.abs(n);
    const cur = abs.toLocaleString('ja-JP', { style:'currency', currency:'JPY', maximumFractionDigits: 0 });
    return sign + cur;
  }


  // compatibility alias (older versions used formatJPY)
  function formatJPY(n){
    return yen(n);
  }

  
function coinGeckoUrlFor(coin){
    const id = coin?.id;
    if (id) return `https://www.coingecko.com/en/coins/${encodeURIComponent(id)}`;
    const q = encodeURIComponent(coin?.name || coin?.symbol || '');
    return `https://www.coingecko.com/en/search?query=${q}`;
  }

  function fireCtaClick({ cta_id, placement, partner, pr, link_url }){
    console.log('fireCtaClick called', {cta_id, placement, partner, pr, link_url, gtag: typeof gtag});
    if (typeof gtag !== 'function') return;
    gtag('event', 'cta_click', {
      cta_id: cta_id || '',
      placement: placement || '',
      partner: partner || '',
      pr: Number(pr) || 0,
      link_url: link_url || '',
      transport_type: 'beacon',
      debug_mode: true
    });
  }

  function openCoinGecko(coin){
    const url = coinGeckoUrlFor(coin);
    window.open(url, '_blank', 'noopener');
  }

  // ============ Data ============
  let marketsTop = [];          // top250
  let trendingCoins = [];
  let summaryAvgSeries = null; // for top sparkline (avg return 7d series)

    let summaryMcapSeries = []; // session sparkline (total market cap top250)
const EXCLUDE_MCAP_IDS = new Set([
    "tether","usd-coin","dai","true-usd","first-digital-usd","ethena-usde",
    "pax-dollar","frax"
  ]);

  const EXCLUDE_MCAP_KEYWORDS = [
    "stable","tether","usd coin","us dollar"
  ];

  function isExcludedForMarketCap(c){
    const id = (c?.id || "").toLowerCase();
    const name = (c?.name || "").toLowerCase();
    const sym = (c?.symbol || "").toLowerCase();
    if (EXCLUDE_MCAP_IDS.has(id)) return true;
    return EXCLUDE_MCAP_KEYWORDS.some(k => name.includes(k) || sym.includes(k));
  }
  async function loadMarketsTop250(forceNetwork=false){
  const url = 'https://api.coingecko.com/api/v3/coins/markets'
    + '?vs_currency=jpy'
    + '&order=market_cap_desc'
    + '&per_page=250&page=1'
    + '&sparkline=true'
    + '&price_change_percentage=24h,7d';

  // まずキャッシュで即表示（ネット失敗でも「真っ白」を避ける）
  const cached = readCache(LS_KEYS.markets);
  if (cached && Array.isArray(cached.data) && cached.data.length){
    marketsTop = cached.data;
  }

  // F5連打など短時間の再読み込みはネット取得をスキップ（API制限対策）
  const now = Date.now();
  const lastFetchAt = getLastFetchAt();
  const canSkipNetwork = !forceNetwork && (now - lastFetchAt) < BOOT_NETWORK_COOLDOWN_MS;
  if (canSkipNetwork && marketsTop.length){
    setStatus('保存済みデータを表示中（自動で最新に切り替わります）');
    return;
  }

  try{
    const fresh = await fetchJsonRetry(url, {retries:2});
    if (Array.isArray(fresh) && fresh.length){
      marketsTop = fresh;
      writeCache(LS_KEYS.markets, fresh);
      setLastFetchAt();
    } else if (!Array.isArray(marketsTop) || !marketsTop.length){
      marketsTop = [];
    }
  } catch (e){
    // キャッシュがあるならそれで継続。無いならエラーを投げる
    if (marketsTop && marketsTop.length){
      console.warn('markets fetch failed, using cache:', e);
      setStatus('最新データの取得が遅れています（保存済みデータを表示中）');
      return;
    }
    throw e;
  }
}


  
  // BTC MA cross (SMA50/SMA200) 用データ
  window.__btcMaCross = null;

  async function loadBtcMaCross(){
    // CoinGeckoのmarket_chartは近年、Publicユーザーだと期間制限/ CORSで失敗しやすい。
    // そこで「追加APIなし」の範囲で、ブラウザから取得できるBinanceのOHLC(日足)で 50/200MA を推定する。
    // ※価格通貨はUSDTだが、MA距離(%)は通貨に依存しないため問題なし。
    const url = 'https://api.binance.com/api/v3/klines'
      + '?symbol=BTCUSDT'
      + '&interval=1d'
      + '&limit=260'; // 200MA + 50MA + 少し余裕

    const rows = await fetchJsonRetry(url, {retries:2});
    if (!Array.isArray(rows) || rows.length < 210) throw new Error('binance klines too short');

    // close価格（index 4）
    const closes = rows.map(r => +r[4]).filter(v => isFinite(v) && v > 0);
    if (closes.length < 210) throw new Error('binance closes invalid');

    const sma = (arr, n) => {
      const a = arr.slice(-n);
      const s = a.reduce((x,y)=>x+y,0);
      return s / n;
    };

    const sma50 = sma(closes, 50);
    const sma200 = sma(closes, 200);
    const price = closes[closes.length-1];

    // KPI: SMA50 vs SMA200（%）
    const distPct = ((sma50 - sma200) / sma200) * 100;

    const near = Math.abs(distPct) <= 0.20; // 0.2%以内を「クロス付近」の目安
    const label = near ? 'クロス付近' : (distPct > 0 ? 'GC側' : 'DC側');
window.__btcMaCross = {
      price, sma50, sma200, distPct,
      label,
      updatedAt: Date.now(),
    };
  }


async function loadTrendingTop5(forceNetwork=false){
  const trendUrl = 'https://api.coingecko.com/api/v3/search/trending';

  // キャッシュ（ids + 最小スナップショット）から先に組み立て
  function setFromCache(ids, snap){
    const idsArr = Array.isArray(ids) ? ids : (Array.isArray(snap) ? snap.map(x => x && x.id).filter(Boolean) : []);
    if (!idsArr.length){ trendingCoins = []; return; }

    const byIdTop = new Map(marketsTop.map(x => [x.id, x]));
    const byIdSnap = new Map((Array.isArray(snap) ? snap : []).filter(Boolean).map(x => [x.id, x]));

    trendingCoins = idsArr
      .map(id => byIdTop.get(id) || byIdSnap.get(id))
      .filter(Boolean);
  }

  const cachedIdsObj = readCache(LS_KEYS.trendingIds);
  const cachedSnapObj = readCache(LS_KEYS.trendingSnapshot);
  const cachedIds = (cachedIdsObj && Array.isArray(cachedIdsObj.data)) ? cachedIdsObj.data : null;
  const cachedSnap = (cachedSnapObj && Array.isArray(cachedSnapObj.data)) ? cachedSnapObj.data : null;

  const cachedIdsCount = cachedIds ? cachedIds.length : 0;
  const cachedSnapCount = cachedSnap ? cachedSnap.length : 0;

  if (cachedIdsCount || cachedSnapCount){
    setFromCache(cachedIds, cachedSnap);
  }

  // markets が取れていない場合は無理に進めない
  if (!marketsTop.length){
    trendingCoins = [];
    return;
  }

  // F5連打など短時間の再読み込みはネット取得をスキップ（API制限対策）
  const now = Date.now();
  const lastFetchAt = getLastFetchAt();
  const canSkipNetwork = !forceNetwork && (now - lastFetchAt) < BOOT_NETWORK_COOLDOWN_MS;

  // キャッシュIDsから組み立てた結果が5件未満（＝top250に無い銘柄が混ざっている等）の場合は、
  // クールダウン中でもネット取得を行って欠けを埋める
  const wantCount = Math.min(5, cachedIdsCount || cachedSnapCount || 5);
  const hasAllCached = trendingCoins.length >= wantCount;

  if (canSkipNetwork && hasAllCached){
    return;
  }

  try{
    const trendJson = await fetchJsonRetry(trendUrl, {retries:2});
    // NOTE: /search/trending の先頭5件に欠損(item/idなし)が混ざることがあるため、
    // idがあるものだけを拾ってから上位5件に絞る（#5が欠ける問題の対策）
    const trendItems = (trendJson.coins || [])
      .map(c => c.item)
      .filter(it => it && it.id)
      .slice(0,5);

    const ids = trendItems.map(it => it.id);

    if (!ids.length){ trendingCoins = []; return; }

    // top250 から拾う
    const byIdTop = new Map(marketsTop.map(x => [x.id, x]));

    // 不足があれば、そのidsだけ markets で1回取得（最小）
    const missing = ids.filter(id => !byIdTop.has(id));
    if (missing.length){
      const mUrl = 'https://api.coingecko.com/api/v3/coins/markets'
        + '?vs_currency=jpy'
        + '&ids=' + encodeURIComponent(missing.join(','))
        + '&sparkline=true'
        + '&price_change_percentage=24h';
      const extra = await fetchJsonRetry(mUrl, {retries:2});
      const extraArr = Array.isArray(extra) ? extra : [];
      for (const x of extraArr) byIdTop.set(x.id, x);
    }

    // それでも markets が取れないIDは、trendingレスポンスの item/data から最小オブジェクトを作って表示する
    const fallbackById = new Map(trendItems.map(it => [it.id, it]));
    trendingCoins = ids.map(id => {
      const m = byIdTop.get(id);
      if (m) return m;

      const it = fallbackById.get(id);
      if (!it) return null;

      // trending の data は形式が変わることがあるので、防御的に拾う
      const data = it.data || {};
      const spark = Array.isArray(data.sparkline) ? data.sparkline
        : (data.sparkline_in_7d && Array.isArray(data.sparkline_in_7d.price) ? data.sparkline_in_7d.price : null);

      // price_change_percentage_24h がオブジェクトの場合は jpy を優先、なければ最初の数値を拾う
      let pch = null;
      const pchAny = data.price_change_percentage_24h;
      if (typeof pchAny === 'number') pch = pchAny;
      else if (pchAny && typeof pchAny === 'object'){
        if (typeof pchAny.jpy === 'number') pch = pchAny.jpy;
        else {
          for (const v of Object.values(pchAny)){
            if (typeof v === 'number'){ pch = v; break; }
          }
        }
      }

      // price / volume は通貨別オブジェクトのことがある（jpy優先）
      const pickNum = (x) => {
        if (typeof x === 'number') return x;
        if (x && typeof x === 'object'){
          if (typeof x.jpy === 'number') return x.jpy;
          for (const v of Object.values(x)){
            if (typeof v === 'number') return v;
          }
        }
        return null;
      };

      const price = pickNum(data.price);
      const vol = pickNum(data.total_volume);

      return {
        id,
        name: it.name || id,
        symbol: it.symbol || '',
        image: it.small || it.thumb || '',
        market_cap_rank: it.market_cap_rank || null,
        current_price: price,
        total_volume: vol,
        price_change_percentage_24h: pch,
        // Chart.js の描画系が期待する形に合わせる
        sparkline_in_7d: spark ? { price: spark } : undefined,
      };
    }).filter(Boolean);

    writeCache(LS_KEYS.trendingIds, ids);

    // 最小スナップショットも保存（TOP250外の銘柄でも次回F5で5件を維持するため）
    const snap = (trendingCoins || []).slice(0,5).map(c => {
      const sp = c && c.sparkline_in_7d && Array.isArray(c.sparkline_in_7d.price) ? c.sparkline_in_7d.price : null;
      // localStorage肥大化を防ぐため、スパークラインは末尾最大240点だけ保持
      const spTrim = sp ? sp.filter(v => typeof v === 'number' && Number.isFinite(v)).slice(-240) : null;
      return {
        id: c.id,
        name: c.name,
        symbol: c.symbol,
        image: c.image,
        market_cap_rank: c.market_cap_rank ?? null,
        current_price: (typeof c.current_price === 'number' && Number.isFinite(c.current_price)) ? c.current_price : null,
        total_volume: (typeof c.total_volume === 'number' && Number.isFinite(c.total_volume)) ? c.total_volume : null,
        price_change_percentage_24h: (typeof c.price_change_percentage_24h === 'number' && Number.isFinite(c.price_change_percentage_24h)) ? c.price_change_percentage_24h : null,
        sparkline_in_7d: spTrim ? { price: spTrim } : undefined,
      };
    });
    writeCache(LS_KEYS.trendingSnapshot, snap);
  } catch (e){
    if (trendingCoins && trendingCoins.length){
      console.warn('trending fetch failed, using cache/top:', e);
      return;
    }
    throw e;
  }
}

function buildMarketCapTop20(){
    // 時価総額は全体（ステーブル含む）
    return marketsTop
      .filter(c => typeof c.market_cap === "number")
      .slice(0,20);
  }

function getMarketCapTop20(){
  if (marketsTop && marketsTop.length){
    const coins = buildMarketCapTop20();
    // mcapは20件なので、sparklineは保存せず（容量節約）。必要ならここで追加可。
    try{
      const snap = (coins || []).slice(0,20).map(c => {
        if(!c) return null;
        return {
          id: c.id,
          name: c.name,
          symbol: c.symbol,
          image: c.image,
          market_cap_rank: c.market_cap_rank ?? null,
          current_price: (typeof c.current_price === 'number' && Number.isFinite(c.current_price)) ? c.current_price : null,
          market_cap: (typeof c.market_cap === 'number' && Number.isFinite(c.market_cap)) ? c.market_cap : null,
          total_volume: (typeof c.total_volume === 'number' && Number.isFinite(c.total_volume)) ? c.total_volume : null,
          price_change_percentage_24h: (typeof c.price_change_percentage_24h === 'number' && Number.isFinite(c.price_change_percentage_24h)) ? c.price_change_percentage_24h : null,
        };
      }).filter(Boolean);
      writeCache(LS_KEYS.mcapSnapshot, snap);
    }catch(e){}
    return coins;
  }
  const cached = readCache(LS_KEYS.mcapSnapshot);
  const snap = (cached && Array.isArray(cached.data)) ? cached.data : null;
  return Array.isArray(snap) ? snap : [];
}

  // 上昇率ノイズ対策：24h出来高 下限（※marketsTopは vs_currency=jpy なので total_volume もJPY）
  const MIN_GAINERS_24H_VOLUME_JPY = 500_000_000; // 例：5億円（必要に応じて調整）


  // ===== Ranking rules (stable / major) =====
  const STABLE_IDS = new Set([
    "tether","usd-coin","dai","true-usd","first-digital-usd","ethena-usde",
    "frax","pax-dollar","paypal-usd","gemini-dollar","paxos-standard","binance-usd","liquity-usd"
  ]);
  const STABLE_SYMBOLS = new Set([
    "usdt","usdc","dai","tusd","usde","fdusd","pyusd","gusd","usdp","busd","lusd","frax"
  ]);
  function isStableCoin(c){
    const id = (c?.id || "").toLowerCase();
    const sym = (c?.symbol || "").toLowerCase();
    const name = (c?.name || "").toLowerCase();
    if (STABLE_IDS.has(id) || STABLE_SYMBOLS.has(sym)) return true;
    // fallback heuristic (軽め)
    if (name.includes("stable") && (name.includes("usd") || sym.includes("usd"))) return true;
    return false;
  }
  function isBtcOrEth(c){
    const id = (c?.id || "").toLowerCase();
    const sym = (c?.symbol || "").toLowerCase();
    return id === "bitcoin" || id === "ethereum" || sym === "btc" || sym === "eth";
  }

  function buildGainersTop5(){
    // ベース条件：24h騰落率が取れる & ステーブル除外
    const base = marketsTop
      .filter(c => typeof c.price_change_percentage_24h === 'number' && Number.isFinite(c.price_change_percentage_24h))
      .filter(c => !isStableCoin(c));

    // 優先：出来高下限を満たす銘柄から上昇率TOP5
    const primary = base
      .filter(c => typeof c.total_volume === 'number' && Number.isFinite(c.total_volume))
      .filter(c => c.total_volume >= MIN_GAINERS_24H_VOLUME_JPY)
      .slice()
      .sort((a,b) => b.price_change_percentage_24h - a.price_change_percentage_24h);

    if (primary.length >= 5) return primary.slice(0,5);

    // 不足時：出来高下限なしの候補で補完（出来高が厚い順で安全寄りに埋める）
    const picked = new Set(primary.map(x => x.id));
    const fallback = base
      .filter(c => typeof c.total_volume === 'number' && Number.isFinite(c.total_volume))
      .slice()
      .sort((a,b) => (b.total_volume || 0) - (a.total_volume || 0));

    for (const c of fallback){
      if (primary.length >= 5) break;
      if (!picked.has(c.id)){
        primary.push(c);
        picked.add(c.id);
      }
    }
    return primary.slice(0,5);
  }


// ▼▼▼ 修正版：出来高ランキングのロジック（Wrapped系は共通で除外） ▼▼▼

// 共通の除外キーワード（Wrappedトークンなど、重複やノイズになるもの）
const SKIP_KEYWORDS = ["wrapped", "staked", "bridged", "token", "wbtc", "weth", "steth"];

function isWrappedOrDuplicate(c) {
  const name = (c.name || '').toLowerCase();
  const sym = (c.symbol || '').toLowerCase();
  // BitcoinやEthereumそのものは除外しない
  if (c.id === 'bitcoin' || c.id === 'ethereum') return false;
  // キーワードチェック
  return SKIP_KEYWORDS.some(k => name.includes(k) || sym.includes(k));
}

// 1. 全体の出来高 TOP5（ステーブルは含める、Wrappedは除外）
function buildVolumeTop5(){
  return marketsTop
    .filter(c => typeof c.total_volume === "number")
    // Wrapped系/重複トークンだけは除外（USDT/USDCなどは残る）
    .filter(c => !isWrappedOrDuplicate(c))
    .slice()
    .sort((a,b) => b.total_volume - a.total_volume)
    .slice(0,5);
}

// 2. アルトコインの出来高 TOP5（ステーブル・BTC/ETH・Wrappedをすべて除外）
function buildAltVolumeTop5(){
  return marketsTop
    .filter(c => typeof c.total_volume === "number")
    // ステーブルコインを除外
    .filter(c => !isStableCoin(c))
    // BTCとETHを除外
    .filter(c => !isBtcOrEth(c))
    // Wrapped系も除外
    .filter(c => !isWrappedOrDuplicate(c))
    .slice()
    .sort((a,b) => b.total_volume - a.total_volume)
    .slice(0,5);
}
function getGainersTop5(){
  if (marketsTop && marketsTop.length){
    const coins = buildGainersTop5();
    writeSnapshot(LS_KEYS.gainersSnapshot, coins);
    return coins;
  }
  return readSnapshot(LS_KEYS.gainersSnapshot);
}

function getVolumeTop5(){
  if (marketsTop && marketsTop.length){
    const coins = buildVolumeTop5();
    writeSnapshot(LS_KEYS.volumeSnapshot, coins);
    return coins;
  }
  return readSnapshot(LS_KEYS.volumeSnapshot);
}



function getAltVolumeTop5(){
  if (marketsTop && marketsTop.length){
    const coins = buildAltVolumeTop5();
    writeSnapshot(LS_KEYS.altVolumeSnapshot, coins);
    return coins;
  }
  return readSnapshot(LS_KEYS.altVolumeSnapshot);
}

  // ============ Market Overview ============

  function fmtPct(n){
    if (typeof n !== 'number' || !isFinite(n)) return '-';
    const s = (n>=0?'+':'');
    return s + n.toFixed(2) + '%';
  }


  // ===== Summary mini visuals (v68) =====
  function updateSummaryRsiBar(val){
    const marker = document.getElementById('sumRsiMarker');
    if(!marker) return;
    if(typeof val !== 'number' || !isFinite(val)){
      marker.style.left = '50%';
      marker.style.opacity = '0.25';
      marker.style.boxShadow = '0 0 0 3px rgba(59,130,246,0.18)';
      return;
    }
    const v = Math.max(0, Math.min(100, val));
    marker.style.left = v.toFixed(1) + '%';
    marker.style.opacity = '1';
    if (v >= 70) marker.style.boxShadow = '0 0 0 3px rgba(34,197,94,0.25)';
    else if (v <= 30) marker.style.boxShadow = '0 0 0 3px rgba(239,68,68,0.25)';
    else marker.style.boxShadow = '0 0 0 3px rgba(59,130,246,0.25)';
  }


  function updateSummaryMaBar(distPct){
    const marker = document.getElementById('sumMaMarker');
    if (!marker) return;

    if (!Number.isFinite(distPct)) {
      marker.style.left = '50%';
      marker.style.opacity = '0.35';
      marker.style.boxShadow = '0 0 0 3px rgba(59,130,246,0.18)';
      return;
    }

    const range = 20; // ±20% を表示レンジに（超過はクランプ）
    const d = Math.max(-range, Math.min(range, distPct));
    const left = (d + range) / (2 * range) * 100;
    marker.style.left = `${left}%`;
    marker.style.opacity = '1';

    // 色味は「危険→安全（赤→黄→青→緑）」に合わせる（下→上）
    if (d <= -range * 0.5) marker.style.boxShadow = '0 0 0 3px rgba(239,68,68,0.22)';        // 下(大)
    else if (d < 0)        marker.style.boxShadow = '0 0 0 3px rgba(245,158,11,0.22)';        // 下(小)
    else if (d <  range*0.5) marker.style.boxShadow = '0 0 0 3px rgba(59,130,246,0.22)';      // 上(小)
    else                   marker.style.boxShadow = '0 0 0 3px rgba(34,197,94,0.22)';         // 上(大)
  }


  function updateSummarySentBar(val){
    const marker = document.getElementById('sumSentMarker');
    if(!marker) return;
    if(typeof val !== 'number' || !isFinite(val)){
      marker.style.left = '50%';
      marker.style.opacity = '0.25';
      marker.style.boxShadow = '0 0 0 3px rgba(59,130,246,0.18)';
      return;
    }
    const v = Math.max(0, Math.min(100, val));
    marker.style.left = v.toFixed(1) + '%';
    marker.style.opacity = '1';
    if (v >= 75) marker.style.boxShadow = '0 0 0 3px rgba(34,197,94,0.22)';
    else if (v <= 25) marker.style.boxShadow = '0 0 0 3px rgba(239,68,68,0.22)';
    else if (v >= 50) marker.style.boxShadow = '0 0 0 3px rgba(148,163,184,0.22)';
    else marker.style.boxShadow = '0 0 0 3px rgba(245,158,11,0.22)';
  }
  function updateSummaryDomBar(pcts){
    const elB = document.getElementById('sumDomSegBtc');
    const elE = document.getElementById('sumDomSegEth');
    const elS = document.getElementById('sumDomSegStb');
    const elO = document.getElementById('sumDomSegOth');
    if (!elB || !elE || !elS || !elO) return;

    const pct = Array.isArray(pcts) ? pcts : [0,0,0,0];
    const clamp = (v)=> Math.max(0, Math.min(100, Number(v)||0));
    const b = clamp(pct[0]), e = clamp(pct[1]), s = clamp(pct[2]), o = clamp(pct[3]);
    const total = b + e + s + o || 1;
    const nb = b/total*100, ne = e/total*100, ns = s/total*100, no = o/total*100;

    let left = 0;
    const setSeg = (el, w)=>{
      el.style.left = `${left}%`;
      el.style.width = `${Math.max(0, w)}%`;
      left += w;
    };
    setSeg(elB, nb);
    setSeg(elE, ne);
    setSeg(elS, ns);
    setSeg(elO, Math.max(0, 100 - (nb+ne+ns))); // 誤差吸収
  }

  function updateSummaryAvgSpark(arr){
    const line = document.getElementById('sumAvgSparkLine');
    const fill = document.getElementById('sumAvgSparkFill');
    const zero = document.getElementById('sumAvgSparkZero');
    if(!line || !fill || !zero) return;

    if(!Array.isArray(arr) || arr.length < 2){
      line.setAttribute('points','');
      fill.setAttribute('d','');
      zero.style.display = 'none';
      return;
    }
    // use latest 60 points for speed
    const raw = arr.slice(-60).map(v => +v).filter(v => isFinite(v));
    if(raw.length < 2){
      line.setAttribute('points','');
      fill.setAttribute('d','');
      zero.style.display = 'none';
      return;
    }
    let min = Math.min(...raw);
    let max = Math.max(...raw);
    if(min === max){ min -= 1; max += 1; }

    const W = 100, H = 30, pad = 2;
    const top = pad, bottom = H - pad;

    const pts = raw.map((v,i)=>{
      const x = (i/(raw.length-1)) * W;
      const y = bottom - ((v - min)/(max - min)) * (bottom - top);
      return [x,y];
    });

    const points = pts.map(p => `${p[0].toFixed(2)},${p[1].toFixed(2)}`).join(' ');
    line.setAttribute('points', points);

    const path = `M ${pts[0][0].toFixed(2)} ${bottom.toFixed(2)} L ${pts.map(p=>`${p[0].toFixed(2)} ${p[1].toFixed(2)}`).join(' L ')} L ${pts[pts.length-1][0].toFixed(2)} ${bottom.toFixed(2)} Z`;
    fill.setAttribute('d', path);

    const zy = bottom - ((0 - min)/(max - min)) * (bottom - top);
    if(zy >= top && zy <= bottom){
      zero.setAttribute('y1', zy.toFixed(2));
      zero.setAttribute('y2', zy.toFixed(2));
      zero.style.display = 'block';
    }else{
      zero.style.display = 'none';
    }
  }

  function updateSummaryMcapSpark(arr){
    const line = document.getElementById('sumMcapSparkLine');
    const fill = document.getElementById('sumMcapSparkFill');
    if(!line || !fill) return;

    if(!Array.isArray(arr) || arr.length < 2){
      line.setAttribute('points','');
      fill.setAttribute('d','');
      return;
    }
    const rawAbs = arr.slice(-60).map(v => +v).filter(v => isFinite(v));
    const base = (rawAbs.length && isFinite(rawAbs[0]) && rawAbs[0]!==0) ? rawAbs[0] : null;
    const raw = base ? rawAbs.map(v => (v/base - 1) * 100) : rawAbs;
    if(raw.length < 2){
      line.setAttribute('points','');
      fill.setAttribute('d','');
      return;
    }
    let min = Math.min(...raw);
    let max = Math.max(...raw);
    if(min === max){ min -= 0.01; max += 0.01; }

    const W = 100, H = 30, pad = 2;
    const top = pad, bottom = H - pad;

    const pts = raw.map((v,i)=>{
      const x = (i/(raw.length-1)) * W;
      const y = bottom - ((v - min)/(max - min)) * (bottom - top);
      return [x,y];
    });

    const points = pts.map(p => `${p[0].toFixed(2)},${p[1].toFixed(2)}`).join(' ');
    line.setAttribute('points', points);

    const path = `M ${pts[0][0].toFixed(2)} ${bottom.toFixed(2)} L ${pts.map(p=>`${p[0].toFixed(2)} ${p[1].toFixed(2)}`).join(' L ')} L ${pts[pts.length-1][0].toFixed(2)} ${bottom.toFixed(2)} Z`;
    fill.setAttribute('d', path);
  }


  function buildOverview(){
    const arr = marketsTop || [];
    const n = arr.length;
    let totalMcap = 0;
    let totalVol = 0;

    // 24h market cap change (estimate): reverse-calc yesterday's market cap from price change
    // Assumption: circulating supply is roughly constant over 24h.
    let prevMcapEst = 0;

    let up = 0, down = 0, flat = 0;
    let sumChg = 0, chgN = 0;
    let chgArr = [];

    // Composition (market cap)
    let btc = 0, eth = 0, stable = 0, other = 0;
    // Composition (volume)
    let btcV = 0, ethV = 0, stableV = 0, otherV = 0;

    for (const c of arr){
      const mc = (typeof c.market_cap === 'number' && isFinite(c.market_cap)) ? c.market_cap : 0;
      const vol = (typeof c.total_volume === 'number' && isFinite(c.total_volume)) ? c.total_volume : 0;
      totalMcap += mc;
      totalVol += vol;

      const chg = c.price_change_percentage_24h;
      if (typeof chg === 'number' && isFinite(chg)){
        const denom = 1 + (chg / 100);
        if (denom > 0 && isFinite(denom)) prevMcapEst += (mc / denom);
        else prevMcapEst += mc;

        if (chg > 0) up++;
        else if (chg < 0) down++;
        else flat++;
        sumChg += chg;
        chgN++;
        chgArr.push(chg);
      } else {
        // fallback: if 24h change is missing, keep it neutral (no change)
        prevMcapEst += mc;
      }

      if (c.id === 'bitcoin'){ btc += mc; btcV += vol; }
      else if (c.id === 'ethereum'){ eth += mc; ethV += vol; }
      else if (STABLE_IDS.has(c.id)){ stable += mc; stableV += vol; }
      else { other += mc; otherV += vol; }
    }

    const avgChg = chgN ? (sumChg / chgN) : null;

    let medianChg = null;
    if (chgArr.length){
      const s = chgArr.slice().sort((a,b)=>a-b);
      const mid = Math.floor(s.length / 2);
      medianChg = (s.length % 2) ? s[mid] : (s[mid-1] + s[mid]) / 2;
    }

    const labels = ['BTC','ETH','ステーブル','Others'];
    const values = [btc, eth, stable, Math.max(0, other)];
    const volValues = [btcV, ethV, stableV, Math.max(0, otherV)];

    // Market cap 7d change (estimate from sparkline; supply fixed approximation)
    let mcap7dStart = 0;
    let mcap7dEnd = 0;
    for (const c of arr){
      const mc = (typeof c.market_cap === 'number' && isFinite(c.market_cap)) ? c.market_cap : 0;
      const cp = (typeof c.current_price === 'number' && isFinite(c.current_price)) ? c.current_price : 0;
      const sp = c.sparkline_in_7d && Array.isArray(c.sparkline_in_7d.price) ? c.sparkline_in_7d.price : null;
      if (mc > 0 && cp > 0 && sp && sp.length >= 2){
        const supplyEst = mc / cp; // 供給一定の近似
        const p0 = Number(sp[0]);
        const p1 = Number(sp[sp.length - 1]);
        if (Number.isFinite(p0) && Number.isFinite(p1)){
          mcap7dStart += supplyEst * p0;
          mcap7dEnd   += supplyEst * p1;
        }
      }
    }
    const mcap7dPct = (mcap7dStart > 0) ? ((mcap7dEnd / mcap7dStart) - 1) * 100 : null;
    const mcap7dDelta = (mcap7dStart > 0) ? (mcap7dEnd - mcap7dStart) : null;

    return { labels, values, volValues, totalMcap, totalVol, up, down, flat, avgChg, medianChg, chgN, n, mcap7dPct, mcap7dDelta };
  }

  function drawDonut(canvasId, labels, values){
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    const total = values.reduce((a,b)=>a+(typeof b==='number'?b:0), 0) || 1;
    const dataVals = values.map(v => (typeof v==='number' && isFinite(v)) ? v : 0);

    // 見やすい落ち着いた色（サイトの雰囲気に合わせる）
    const colors = ['rgba(250, 204, 21, 0.85)','rgba(96, 165, 250, 0.85)','rgba(52, 211, 153, 0.85)','rgba(156, 163, 175, 0.55)'];

    charts[canvasId] = new Chart(canvas, {
      type: 'doughnut',
      data: {
        labels,
        datasets: [{ data: dataVals, backgroundColor: colors, borderWidth: 0 }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        plugins: {
          legend: {
            position: 'bottom',
            labels: { color: '#e5e7eb', boxWidth: 10, padding: 12 }
          },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const v = ctx.parsed || 0;
                const p = (v/total)*100;
                return ` ${ctx.label}: ${p.toFixed(2)}%`;
              }
            }
          }
        }
      }
    });
  }

  function renderOverview(){
    const msg = document.getElementById('overviewMsg');
    msg.style.display = 'none';

    // reset mini series cache each run
    summaryAvgSeries = null;

    if (!marketsTop || !marketsTop.length){
      msg.className = 'msg err';
      msg.textContent = '概況データを準備中です。';
      msg.style.display = 'block';
      return;
    }

    const o = buildOverview();

    const wrap = document.getElementById('overviewWrap');
    const isCollapsed = wrap && wrap.classList.contains('is-collapsed');

    let lastUp = null, lastDown = null;
    let avg7 = null, med7 = null;
    let sentScore = null, sentLabel = null;
    let lastRsiVal = null;

    // Breadth
    const denom = (o.up + o.down + o.flat) || 1;
    const upPct = (o.up / denom) * 100;
    const flatPct = (o.flat / denom) * 100;
    const downPct = (o.down / denom) * 100;

    
const breadthNowEl = document.getElementById('kpiBreadthNow');
if (breadthNowEl){
  // 24h snapshot (from /coins/markets price_change_percentage_24h)
  breadthNowEl.textContent = `24h: 上昇 ${o.up} / 下落 ${o.down}` + (o.flat ? `（中立 ${o.flat}）` : '');
}

// Strong movers (24h)
let up10 = 0, down10 = 0;
for (const c of (marketsTop || [])){
  const chg = c && c.price_change_percentage_24h;
  if (typeof chg === 'number' && isFinite(chg)){
    if (chg >= 10) up10++;
    if (chg <= -10) down10++;
  }
}
const breadthMovesEl = document.getElementById('kpiBreadthMoves');
if (breadthMovesEl){
  breadthMovesEl.textContent = `強い動き(24h): +10%≥ ${up10} / -10%≤ ${down10}`;
}

    
const breadthSub = document.getElementById('kpiBreadthSub');
if (breadthSub){
  const baseTxt = `対象: 上位250（取得 ${o.n}）のうち、24h騰落率が取得できた ${o.chgN} 銘柄を集計`;
  breadthSub.setAttribute('data-base', baseTxt); // for debug / future use
}

    const barUp = document.getElementById('barUp');
    const barFlat = document.getElementById('barFlat');
    const barDown = document.getElementById('barDown');
    if (barUp) barUp.style.width = `${upPct}%`;
    if (barFlat) barFlat.style.width = `${flatPct}%`;
    if (barDown) barDown.style.width = `${downPct}%`;

    // Average change
    const avgEl = document.getElementById('kpiAvgChange');
    if (avgEl){
      avgEl.textContent = `平均 ${fmtPct(o.avgChg)} / 中央値 ${fmtPct(o.medianChg)}`;
    }
    const avgFill = document.getElementById('avgFill');
    if (avgFill){
      const maxRange = 5; // ±5% を目安に可視化（超過はクリップ）
      const v = (typeof o.avgChg === 'number' && isFinite(o.avgChg)) ? o.avgChg : 0;
      const w = Math.min(Math.abs(v), maxRange) / maxRange * 50; // 0..50
      if (v >= 0){
        avgFill.className = 'centerfill pos';
        avgFill.style.left = '50%';
        avgFill.style.width = `${w}%`;
      } else {
        avgFill.className = 'centerfill neg';
        avgFill.style.left = `${50 - w}%`;
        avgFill.style.width = `${w}%`;
      }
    }

    // Totals
    // 安全に更新するように変更
    const elMcap = document.getElementById('kpiTotalMcap');
    if (elMcap) elMcap.textContent = yenLarge(o.totalMcap);

    const elVol = document.getElementById('kpiTotalVol');
    if (elVol) elVol.textContent = yenLarge(o.totalVol);

    // Market cap 24h change (estimate)
    const mcap24hEl = document.getElementById('kpiMcap7d');
    if (mcap24hEl){
      const pct = fmtPct(o.mcap7dPct);
      // ▼ 修正後：符号をつけて yenLarge で丸める
      const dVal = o.mcap7dDelta;
      const absVal = Math.abs(dVal);
      // yenLargeは絶対値で計算して「¥〇〇兆」を返すため、手動で符号をつける
      const delta = (dVal >= 0 ? '+' : '-') + yenLarge(absVal);
      mcap24hEl.textContent = `${pct}（${delta}）`;
    }

    // Composition bars (market cap)
    const totalM = (o.values || []).reduce((a,b)=>a+((typeof b==='number'&&isFinite(b))?b:0), 0) || 1;
    const mPct = (o.values || []).map(v => (((typeof v==='number'&&isFinite(v))?v:0)/totalM)*100);
    const setW = (id, w) => { const el = document.getElementById(id); if (el) el.style.width = `${w}%`; };
    setW('mcapSegBtc', mPct[0] || 0);
    setW('mcapSegEth', mPct[1] || 0);
    setW('mcapSegStable', mPct[2] || 0);
    setW('mcapSegOther', mPct[3] || 0);

    // Composition bars (volume)
    const totalV = (o.volValues || []).reduce((a,b)=>a+((typeof b==='number'&&isFinite(b))?b:0), 0) || 1;
    const vPct = (o.volValues || []).map(v => (((typeof v==='number'&&isFinite(v))?v:0)/totalV)*100);
    const altRatio = ((((o.volValues || [])[3] || 0) * 1) / totalV) * 100;
    const elAltRatio = document.getElementById('kpiAltVolRatio');
    if (elAltRatio) elAltRatio.textContent = `出来高（アルト）比率: ${isFinite(altRatio) ? altRatio.toFixed(1) : '-'}%`;
    setW('volSegBtc', vPct[0] || 0);
    setW('volSegEth', vPct[1] || 0);
    setW('volSegStable', vPct[2] || 0);
    setW('volSegOther', vPct[3] || 0);



    // ---- Overview line series (API追加なし: sparkline_in_7d から算出) ----
    try {
      const seriesLen = (marketsTop && marketsTop[0] && marketsTop[0].sparkline_in_7d && marketsTop[0].sparkline_in_7d.price) ? marketsTop[0].sparkline_in_7d.price.length : 0;
      if (seriesLen > 2) {
        const upArr = new Array(seriesLen).fill(0);
        const downArr = new Array(seriesLen).fill(0);
        const flatArr = new Array(seriesLen).fill(0);
        const avgArr = new Array(seriesLen).fill(0);
        const mcapArr = new Array(seriesLen).fill(0);
        const volArr = new Array(seriesLen).fill(0);
        const cntArr = new Array(seriesLen).fill(0);
        const lastRets = []; // latest-point 7d returns for median

        for (let i=0;i<marketsTop.length;i++){
          const c = marketsTop[i];
          const sp = c && c.sparkline_in_7d && c.sparkline_in_7d.price;
          if (!sp || sp.length !== seriesLen) continue;
          const p0 = sp[0];
          const plast = sp[seriesLen-1];
          if (!(p0>0) || !(plast>0)) continue;
          const mcNow = (typeof c.market_cap === 'number' && isFinite(c.market_cap)) ? c.market_cap : 0;
          const volNow = (typeof c.total_volume === 'number' && isFinite(c.total_volume)) ? c.total_volume : 0;

          // latest 7d return for median (from first available price to latest)
          const retLast = (plast / p0 - 1) * 100;
          if (isFinite(retLast)) lastRets.push(retLast);
          for (let t=0;t<seriesLen;t++){
            const pt = sp[t];
            if (!(pt>0)) continue;
            const ret = (pt/p0 - 1) * 100;
            if (ret > 0) upArr[t] += 1;
            else if (ret < 0) downArr[t] += 1;
            else flatArr[t] += 1;
            avgArr[t] += ret;
            cntArr[t] += 1;
            // 推定: supply一定近似
            if (mcNow>0) mcapArr[t] += mcNow * (pt/plast);
            if (volNow>0) volArr[t] += volNow * (pt/plast);
          }
        }
        for (let t=0;t<seriesLen;t++){
          if (cntArr[t]>0) avgArr[t] = avgArr[t] / cntArr[t];
        }
        summaryAvgSeries = avgArr.slice();
        // Labels: just indexes (Chart.js will hide axis anyway)
        const labels = Array.from({length: seriesLen}, (_,i)=>i);

        // Breadth chart (2 lines)
        makeLineChart('breadthLine', labels, [
          {label:'上昇', data: upArr, border:'rgba(30,136,229,0.9)', fill:false},
          {label:'下落', data: downArr, border:'rgba(211,47,47,0.9)', fill:false}
        ], {yBeginAtZero:true, dayGrid:true});

        // Avg return chart (0 baseline fill)
        makeBaselineChart('avgLine', labels, avgArr, {dayGrid:true});
        // KPI表示を「7d推移」ベース（最新点）に合わせる
        lastUp = upArr[upArr.length - 1];
        lastDown = downArr[downArr.length - 1];
        const lastAvg = avgArr[avgArr.length - 1];
        const kpiB = document.getElementById('kpiBreadth');
        if (kpiB){
          const lastFlat = Number(flatArr[flatArr.length - 1]) || 0;
          const denom = (Number(lastUp)||0) + (Number(lastDown)||0) + lastFlat;
          const upPct = denom ? ((Number(lastUp)||0) / denom) * 100 : 0;
          kpiB.textContent = `7d累積: 上昇 ${lastUp} / 下落 ${lastDown}` + ((Number(flatArr[flatArr.length - 1])||0)>0 ? `（中立 ${flatArr[flatArr.length - 1]}）` : '') + `（上昇率 ${upPct.toFixed(1)}%）`;
        }
        const kpiAvg = document.getElementById('kpiAvgChange');
        if (kpiAvg){
          let med = null;
          if (lastRets.length){
            const s = lastRets.slice().sort((a,b)=>a-b);
            const mid = Math.floor(s.length/2);
            med = (s.length % 2) ? s[mid] : (s[mid-1] + s[mid]) / 2;
          }
          kpiAvg.textContent = `平均 ${fmtPct(lastAvg)} / 中央値 ${fmtPct(med)}`;
          const kpiAvgDist = document.getElementById('kpiAvgDist');
          if (kpiAvgDist){
            const total = lastRets.length || 0;
            if (total){
              let up5 = 0, down5 = 0;
              for (const v of lastRets){
                if (typeof v === 'number' && isFinite(v)){
                  if (v >= 5) up5++;
                  if (v <= -5) down5++;
                }
              }
              const upPct = up5 / total * 100;
              const downPct = down5 / total * 100;
              kpiAvgDist.textContent = `±5%: ↑${up5}（${upPct.toFixed(1)}%） / ↓${down5}（${downPct.toFixed(1)}%）`;
            } else {
              kpiAvgDist.textContent = '-';
            }
          }
        avg7 = lastAvg;
        med7 = med;
        }


        
        // BTC RSI (14) from BTC sparkline (7d)
        try {
          const btc = marketsTop.find(c => c && c.id === 'bitcoin');
          const btcPrices = btc && btc.sparkline_in_7d && Array.isArray(btc.sparkline_in_7d.price) ? btc.sparkline_in_7d.price : null;
          if (btcPrices && btcPrices.length >= 20) {
            const rsiSeries = computeRSISeries(btcPrices, 14);
            const last = rsiSeries[rsiSeries.length - 1];
            lastRsiVal = last;
            const rsiEl = document.getElementById('kpiRsi');
            if (rsiEl && last != null && isFinite(last)) {
              let tag = '中立';
              if (last >= 70) tag = '買われすぎ';
              else if (last <= 30) tag = '売られすぎ';
              rsiEl.textContent = `RSI ${last.toFixed(1)}（${tag}）`;
            }
            
            const rsiMetaEl = document.getElementById('kpiRsiMeta');
            if (rsiMetaEl && Array.isArray(rsiSeries) && rsiSeries.length) {
              const finite = rsiSeries.filter(v => v != null && isFinite(v));
              if (finite.length) {
                const mn = Math.min(...finite);
                const mx = Math.max(...finite);
                const d30 = (last - 30);
                const d70 = (70 - last);
                const d30txt = isFinite(d30) ? Math.max(0, d30).toFixed(1) : '-';
                const d70txt = isFinite(d70) ? Math.max(0, d70).toFixed(1) : '-';
                rsiMetaEl.textContent = `7d範囲 ${mn.toFixed(1)}–${mx.toFixed(1)} / 30まで ${d30txt}pt / 70まで ${d70txt}pt`;
              } else {
                rsiMetaEl.textContent = '-';
              }
            }
// use the same label length as other sparklines
            const rsiLabels = Array.from({length: rsiSeries.length}, (_, i) => i);

            // Draw RSI (0-100固定)。30/70の閾値ラインはDOMオーバーレイで表示（Chart.js差分に依存しない）
            makeLineChart('rsiLine', rsiLabels, [
              {
                label: 'RSI',
                data: rsiSeries,
                borderColor: 'rgba(255,255,255,0.92)',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.35,
                fill: false
              }
            ], {
              dayGrid:true,
              yMin: 0,
              yMax: 100,
              hLines: {
                lines: [
                  { value: 30, color: 'rgba(59,130,246,0.75)', width: 1, dash: [] },
                  { value: 70, color: 'rgba(239,68,68,0.75)', width: 1, dash: [] }
                ]
              }
            });
}
        } catch(e) { console.warn('RSI failed', e); }

        // CoinRader Sentiment (0-100) — top250ベース
        try{
          const denomS = (Number(lastUp)||0) + (Number(lastDown)||0);
          const upPctS = denomS ? ((Number(lastUp)||0)/denomS)*100 : 0;

          // 24h change median (top250)
          const pct24 = marketsTop.map(c => (c && typeof c.price_change_percentage_24h === 'number' && isFinite(c.price_change_percentage_24h)) ? c.price_change_percentage_24h : null)
                                .filter(v => v != null);
          let med24 = null;
          if (pct24.length){
            const s = pct24.slice().sort((a,b)=>a-b);
            const mid = Math.floor(s.length/2);
            med24 = (s.length % 2) ? s[mid] : (s[mid-1] + s[mid]) / 2;
          }

          // Total volume change vs previous refresh (localStorage)
          const volNow = marketsTop.reduce((acc,c)=> acc + (Number.isFinite(c && c.total_volume)? c.total_volume : 0), 0);
          const keyVol = 'cr_prev_total_vol';
          const keyVolTs = 'cr_prev_total_vol_ts';
          const prevVol = Number(localStorage.getItem(keyVol));
          const prevVolTs = Number(localStorage.getItem(keyVolTs));
          let volChgPct = null;
          if (prevVol && isFinite(prevVol) && prevVol > 0 && prevVolTs && (Date.now() - prevVolTs) < (12*60*60*1000)){
            volChgPct = (volNow/prevVol - 1) * 100;
          }
          localStorage.setItem(keyVol, String(volNow));
          localStorage.setItem(keyVolTs, String(Date.now()));

          // BTC dominance delta (percentage point) vs previous refresh
          const totalM = (o.values||[]).reduce((a,b)=>a + (Number.isFinite(+b)? +b : 0), 0);
          const btcM = (o.values && o.values.length) ? (Number.isFinite(+o.values[0]) ? +o.values[0] : 0) : 0;
          const btcDom = totalM > 0 ? (btcM/totalM) * 100 : null;
          const keyDom = 'cr_prev_btc_dom';
          const prevDom = Number(localStorage.getItem(keyDom));
          let domDelta = null;
          if (btcDom != null && isFinite(btcDom) && prevDom && isFinite(prevDom)){
            domDelta = btcDom - prevDom;
          }
          if (btcDom != null && isFinite(btcDom)) localStorage.setItem(keyDom, String(btcDom));

          // Normalize helpers
          const clamp = (x,min,max)=> Math.max(min, Math.min(max, x));
          const normBreadth = clamp((upPctS - 50) / 50, -1, 1);             // breadth (0-100%)
          const normMed24   = (med24 == null) ? 0 : clamp(med24 / 10, -1, 1); // median24h (+/-10%)
          const normVol     = (volChgPct == null) ? 0 : clamp(volChgPct / 20, -1, 1); // volΔ (+/-20%)
          const normDom     = (domDelta == null) ? 0 : clamp((-domDelta) / 2, -1, 1);  // dom↓ => risk-on
          const normRsi     = (lastRsiVal == null || !isFinite(lastRsiVal)) ? 0 : clamp((lastRsiVal - 50) / 20, -1, 1);

          const raw = 0.30*normBreadth + 0.25*normMed24 + 0.20*normVol + 0.10*normDom + 0.15*normRsi;
          const score = clamp(50 + 50*raw, 0, 100);

          const label = (score>=81) ? '極度の強欲' : (score>=61) ? '強欲' : (score>=41) ? '中立' : (score>=21) ? '恐怖' : '極度の恐怖';
          sentScore = score;
          sentLabel = label;

          const elS = document.getElementById('kpiSentiment');
          if (elS) elS.textContent = `${score.toFixed(0)}（${label}）`;

          // gauge needle + small label
          // gauge removed in MarketOverview

          const elM = document.getElementById('kpiSentimentMeta');
          if (elM){
            const parts = [];
            parts.push(`上昇率 ${upPctS.toFixed(1)}%`);
            if (med24 != null && isFinite(med24)) parts.push(`24h中央値 ${med24.toFixed(2)}%`);
            if (volChgPct != null && isFinite(volChgPct)) parts.push(`出来高Δ ${volChgPct.toFixed(1)}%`);
            if (domDelta != null && isFinite(domDelta)) parts.push(`BTC Dom Δ ${domDelta.toFixed(2)}pt`);
            if (lastRsiVal != null && isFinite(lastRsiVal)) parts.push(`RSI ${lastRsiVal.toFixed(1)}`);
            elM.textContent = parts.join(' / ');
          }

          // history sparkline (store last 120 points)
          const histKey = 'cr_sent_hist';
          let hist = [];
          try { hist = JSON.parse(localStorage.getItem(histKey) || '[]'); } catch(_){}
          if (!Array.isArray(hist)) hist = [];
          hist.push(Number(score));
          if (hist.length > 120) hist = hist.slice(-120);
          localStorage.setItem(histKey, JSON.stringify(hist));

          const labS = hist.map((_,i)=>i);
          if (charts['sentLine']) { try { charts['sentLine'].destroy(); } catch(_){} }
          // autoscale for visibility (sparkline)
          const valsS = hist.filter(v => v != null && isFinite(v));
          let minS = 0, maxS = 100;
          if (valsS.length){
            minS = Math.min(...valsS);
            maxS = Math.max(...valsS);
            let pad = 6;
            const span = (maxS - minS);
            if (span < 20) pad = Math.max(pad, (20 - span) / 2);
            minS = Math.max(0, minS - pad);
            maxS = Math.min(100, maxS + pad);
          }
          makeLineChart('sentLine', labS, [{
            label:'Sent',
            data: hist,
            border:'rgba(255,255,255,0.95)',
            borderWidth:2.8,
            fill:true,
            bg:'rgba(255,255,255,0.10)',
            tension:0.25,
            pointRadius:0
          }], {yMin:minS, yMax:maxS, dayGrid:true});
        }catch(e){ console.warn('sentiment failed', e); }

        // Market cap estimate (normalize to last for readability)
        makeNormalizedLine('mcapLine', labels, mcapArr, {dayGrid:true});

        // Market cap 7d spark (use full 7d from sparkline)
        try {
          if (mcapArr && mcapArr.length >= 3) {
            makeNormalizedLine('mcap7dLine', labels, mcapArr, {dayGrid:true});
          }
        } catch(_){}

        // Volume estimate (normalize)
        makeNormalizedLine('volLine', labels, volArr, {dayGrid:true});
      }
    } catch(e) { console.warn('overview series failed', e); }

    drawDonut('domChart', o.labels, o.values);
    // Dominance text (BTC/ETH/ステーブル/Others)
    try{
      const domEl = document.getElementById('domMetrics');
      if(domEl){
        const total = (o.values||[]).reduce((a,b)=>a + (Number.isFinite(+b)? +b : 0), 0);
        if(total > 0){
          domEl.textContent = (o.labels||[]).map((lab,i)=>{
            const v = Number.isFinite(+o.values[i]) ? +o.values[i] : 0;
            return `${lab} ${(v/total*100).toFixed(1)}%`;
          }).join(' / ');
        }else{
          domEl.textContent = '-';
        }
      }
    }catch(_){}

    // 見えない状態で初期描画されると幅0でチャートが潰れることがあるため、次のtickでリサイズ

    // --- KPI strip (collapsed view) ---
    (function updateOverviewStrip(){
      const set = (id, txt)=>{ const el=document.getElementById(id); if(el) el.textContent = (txt==null||txt==='') ? '—' : String(txt); };
      // 時価総額
      set('kpiStripMcapMain', formatJPY(o.totalMcap));
      const mcapPct = (o.mcap7dPct==null) ? null : ((o.mcap7dPct>=0?'+':'') + o.mcap7dPct.toFixed(2) + '%');
      const mcapAbs = (o.mcap7dDelta==null) ? null : formatJPY(o.mcap7dDelta);
      set('kpiStripMcapSub', (mcapPct && mcapAbs) ? `24h ${mcapPct} (${mcapAbs})` : (mcapPct||mcapAbs));

      // Dominance
      const domBTC = (o.values && o.values.length) ? (o.values[0]/o.totalMcap*100) : null;
      const domETH = (o.values && o.values.length>1) ? (o.values[1]/o.totalMcap*100) : null;
      const domSTB = (o.values && o.values.length>2) ? (o.values[2]/o.totalMcap*100) : null;
      const domOTH = (o.values && o.values.length>3) ? (o.values[3]/o.totalMcap*100) : null;
      set('kpiStripDomMain', domBTC==null ? null : `${domBTC.toFixed(1)}%`);
      const domSubParts = [];
      if(domETH!=null) domSubParts.push(`ETH ${domETH.toFixed(1)}%`);
      if(domSTB!=null) domSubParts.push(`ステーブル ${domSTB.toFixed(1)}%`);
      if(domOTH!=null) domSubParts.push(`Others ${domOTH.toFixed(1)}%`);
      set('kpiStripDomSub', domSubParts.length? domSubParts.join(' / ') : null);

      // Breadth
      set('kpiStripBreadthMain', (lastUp!=null && lastDown!=null) ? `上昇 ${lastUp} / 下落 ${lastDown}` : null);
      const upRate = (lastUp!=null && lastDown!=null && (lastUp+lastDown)>0) ? (lastUp/(lastUp+lastDown)*100) : null;
      set('kpiStripBreadthSub', upRate==null ? null : `上昇率 ${upRate.toFixed(1)}%`);

      // Avg/Median 7d
      set('kpiStripAvgMain', avg7==null ? null : `平均 ${avg7.toFixed(2)}%`);
      set('kpiStripAvgSub',  med7==null ? null : `中央値 ${med7.toFixed(2)}%`);

      // RSI
      const rsiMain = (typeof lastRsiVal==='number' && isFinite(lastRsiVal)) ? lastRsiVal.toFixed(1) : null;
      set('kpiStripRsiMain', rsiMain);
      // rsi label is already rendered in the full view; keep strip short
      set('kpiStripRsiSub', rsiMain==null ? null : (lastRsiVal>=70 ? '買われすぎ' : (lastRsiVal<=30 ? '売られすぎ' : '中立')));

      // Sentiment
      set('kpiStripSentMain', (sentScore==null) ? null : String(Math.round(sentScore)));
      set('kpiStripSentSub', sentLabel);

      // --- Summary (top) KPI tiles ---
      const setSum = (id, txt)=>{ const el=document.getElementById(id); if(el) el.textContent = (txt==null||txt==='') ? '—' : String(txt); };

      // ▼▼▼ 追加：市場出来高＆アルト比率の表示 ▼▼▼
      (function updateVolTile(){
        const totalV = o.totalVol || 0;
  
        // 1. メイン数値（全体の出来高）
        const elMain = document.getElementById('kpiStripVolMain');
        if(elMain) elMain.textContent = yenLarge(totalV);

        // 2. 構成比率の計算
        const vVals = o.volValues || [0,0,0,0]; // BTC, ETH, Stable, Other
        const btcV = vVals[0] || 0;
        const ethV = vVals[1] || 0;
        // Stableは「その他」に含めるか、除外して考えるかですが、ここでは「Others」に含めます
        const otherV = (vVals[2] || 0) + (vVals[3] || 0);
  
        const btcPct = totalV ? (btcV / totalV) * 100 : 0;
        const ethPct = totalV ? (ethV / totalV) * 100 : 0;
        const otherPct = totalV ? (otherV / totalV) * 100 : 0;

        // 3. サブテキスト（アルト比率を表示）
        // ここでは ETH + Others を「Alt」として扱います
        const altRatio = ethPct + otherPct;
        const elSub = document.getElementById('kpiStripVolSub');
        if(elSub) {
          elSub.textContent = `Alt比率 ${altRatio.toFixed(1)}%`;
          // アルト比率が高いときは少し色を変えて強調
          if(altRatio > 50) elSub.style.color = "#7dd3fc"; // 水色
          else elSub.style.color = "#cbd5e1"; // 通常色
        }

        // 4. ミニバーの更新
        const barBtc = document.getElementById('miniVolBarBtc');
        const barEth = document.getElementById('miniVolBarEth');
        const barOth = document.getElementById('miniVolBarOth');
  
        if(barBtc) barBtc.style.width = `${btcPct}%`;
        if(barEth) barEth.style.width = `${ethPct}%`;
        if(barOth) barOth.style.width = `${otherPct}%`;
      })();
      
      // Sentiment
      setSum('sumSentMain', (sentScore==null) ? null : String(Math.round(sentScore)));
      setSum('sumSentSub', sentLabel);

      // RSI
      const rsiTag = (lastRsiVal==null || !isFinite(lastRsiVal)) ? null : (lastRsiVal>=70 ? '買われすぎ' : (lastRsiVal<=30 ? '売られすぎ' : '中立'));
      setSum('sumRsiMain', (lastRsiVal==null || !isFinite(lastRsiVal)) ? null : String(Math.round(lastRsiVal)));
      setSum('sumRsiSub', rsiTag);

      // Dominance (BTC)
      const totalMc = (o && typeof o.totalMcap==='number' && isFinite(o.totalMcap) && o.totalMcap>0) ? o.totalMcap : null;
      const v0 = (o && o.values && o.values.length>0 && isFinite(o.values[0])) ? o.values[0] : null; // BTC cap
      const v1 = (o && o.values && o.values.length>1 && isFinite(o.values[1])) ? o.values[1] : null; // ETH cap
      const v2 = (o && o.values && o.values.length>2 && isFinite(o.values[2])) ? o.values[2] : null; // stable cap
      const domB = (totalMc && v0!=null) ? (v0/totalMc*100) : null;
      const domE = (totalMc && v1!=null) ? (v1/totalMc*100) : null;
      const domS = (totalMc && v2!=null) ? (v2/totalMc*100) : null;
      setSum('sumDomMain', (domB==null) ? null : (domB.toFixed(1) + '%'));
      const domSub = (domE==null && domS==null) ? null : ((domE==null?'':('ETH ' + domE.toFixed(1) + '%')) + (domE!=null && domS!=null ? ' / ' : '') + (domS==null?'':('Stbl ' + domS.toFixed(1) + '%')));
      setSum('sumDomSub', domSub);

      // Avg 24h (Top250)
      const avg24 = (o && typeof o.avgChg==='number' && isFinite(o.avgChg)) ? o.avgChg : null;
      const med24 = (o && typeof o.medianChg==='number' && isFinite(o.medianChg)) ? o.medianChg : null;
      const fmt2 = (n)=> (n==null) ? '—' : ((n>=0?'+':'') + n.toFixed(2) + '%');
      setSum('sumAvg24Main', fmt2(avg24));
      setSum('sumAvg24Sub', '平均');

      // Avg marker (range -5%..+5%)
      (function(){
        const mEl = document.getElementById('sumAvgMarker');
        if(!mEl) return;
        if(avg24==null || !isFinite(avg24)) { mEl.style.left='50%'; return; }
        const v = Math.max(-5, Math.min(5, avg24));
        const pct = ((v + 5) / 10) * 100;
        mEl.style.left = pct + '%';
      })();

      // Breadth (24h up/down counts, Top250)
      (function(){
        const up = (o && typeof o.up==='number' && isFinite(o.up)) ? o.up : null;
        const down = (o && typeof o.down==='number' && isFinite(o.down)) ? o.down : null;
        const flat = (o && typeof o.flat==='number' && isFinite(o.flat)) ? o.flat : null;
        const total = (up!=null && down!=null) ? (up + down) : null;

        const mainEl = document.getElementById('sumBreadthMain');
        const subEl = document.getElementById('sumBreadthSub');
        if (mainEl){
          if (up==null || down==null) mainEl.textContent = '—';
          else mainEl.textContent = `↑${up} ↓${down}`;
        }
        if (subEl){
          if (up==null || down==null) subEl.textContent = '—';
          else {
            const total2 = up + down;
            const upPct = total2>0 ? Math.round((up/total2)*100) : 50;
            subEl.textContent = (up>=down) ? `上昇優勢 ${upPct}%` : `下落優勢 ${100-upPct}%`;
          }
        }


        const upSeg = document.getElementById('sumBreadthSegUp');
        const downSeg = document.getElementById('sumBreadthSegDown');
        if (upSeg && downSeg){
          if (total && total > 0){
            const upPct = (up / total) * 100;
            const downPct = 100 - upPct;
            upSeg.style.width = `${upPct}%`;
            downSeg.style.width = `${downPct}%`;
            upSeg.style.opacity = '1';
            downSeg.style.opacity = '1';
          } else {
            upSeg.style.width = '50%';
            downSeg.style.width = '50%';
            upSeg.style.opacity = '0.35';
            downSeg.style.opacity = '0.35';
          }
        }
      })();


      // BTC MA cross distance (SMA50 / SMA200)
    const ma = window.__btcMaCross || null;
    if (ma && Number.isFinite(ma.distPct)) {
      const d = ma.distPct;
      const label = ma.label || (d > 0 ? '上' : d < 0 ? '下' : '中立');
      setSum('sumMaMain', `${d>=0?'+':''}${fmtPct(d, 2)}`);
      setSum('sumMaSub', label);
      updateSummaryMaBar(d);
    } else {
      setSum('sumMaMain', '—');
      setSum('sumMaSub', '—');
      updateSummaryMaBar(null);
    }

    // Mini visuals
    updateSummarySentBar(sentScore);
    updateSummaryRsiBar(lastRsiVal);
    updateSummaryDomBar([domBTC, domETH, domSTB, domOTH]);

    })();

    // 折りたたみ時はKPI stripだけ更新して終了（チャートの幅0問題を避ける）
    if (isCollapsed) return;
    setTimeout(() => {
      ['breadthLine','avgLine','rsiLine','sentLine','mcapLine','mcap7dLine','volLine'].forEach(id => {
        try { if (charts[id] && typeof charts[id].resize === 'function') charts[id].resize(); } catch(_){}
      });
    }, 0);

  }

// ============ Charts / Rendering ============
  const charts = {};
  const __sparklineAttempts = new Map(); // canvasId -> attempts

  function clearCharts(){
    Object.values(charts).forEach(c => { try{ c.destroy(); }catch(e){} });
    Object.keys(charts).forEach(k => delete charts[k]);
  
  // --- RSI threshold overlay (30/70) ---
  // Position DOM lines to match Chart.js scale exactly (works across v2/v3+).
  let __rsiOverlayResizeBound = false;
  function syncRsiThresholdOverlay(){
    const chart = charts['rsiLine'];
    const canvas = document.getElementById('rsiLine');
    if (!chart || !canvas) return;

    const wrap = canvas.closest('.rsi-chart-area');
    if (!wrap) return;

    const line70 = wrap.querySelector('.rsi-70');
    const line30 = wrap.querySelector('.rsi-30');
    if (!line70 || !line30) return;

    // Resolve y-scale across Chart.js versions
    let yScale = null;
    if (chart.scales){
      if (chart.scales.y && typeof chart.scales.y.getPixelForValue === 'function'){
        yScale = chart.scales.y;
      } else {
        const all = Object.values(chart.scales);
        yScale = all.find(s => s && typeof s.getPixelForValue === 'function' && (s.axis === 'y' || String(s.id||'').startsWith('y'))) || null;
        if (!yScale) yScale = (chart.scales['y-axis-0'] || chart.scales['y0'] || null);
      }
    }
    if (!yScale || typeof yScale.getPixelForValue !== 'function') return;

    // getPixelForValue() returns coordinates in the chart's internal pixel space.
    // Convert to CSS pixels using (canvas CSS height) / (chart internal height).
    const canvasRect = canvas.getBoundingClientRect();
    const cssH = canvasRect.height || wrap.getBoundingClientRect().height || wrap.clientHeight || 0;
    const internalH = (chart.height || (chart.chart && chart.chart.height) || canvas.height || 0);
    const scale = (cssH && internalH) ? (cssH / internalH) : 1;

    const clamp = (v) => cssH ? Math.max(0, Math.min(cssH, v)) : v;

    const y70 = clamp(yScale.getPixelForValue(70) * scale);
    const y30 = clamp(yScale.getPixelForValue(30) * scale);

    line70.style.top = y70 + 'px';
    line30.style.top = y30 + 'px';

    // Bind observers once (layout can change after charts render / responsive breakpoints)
    if (!__rsiOverlayResizeBound){
      __rsiOverlayResizeBound = true;

      const syncSoon = () => requestAnimationFrame(() => { try{ syncRsiThresholdOverlay(); }catch(_){} });

      window.addEventListener('resize', syncSoon, { passive:true });
      window.addEventListener('orientationchange', syncSoon, { passive:true });

      try{
        const ro = new ResizeObserver(() => syncSoon());
        ro.observe(wrap);
        ro.observe(canvas);
        window.__rsiThreshRO = ro;
      }catch(_){}
    }
  }
}



// スパークライン描画（グラデーション・高級感版）
function drawSparkline(canvasId, data){
  const canvas = document.getElementById(canvasId);
  if(!canvas) return;

  // レイアウト未完了(サイズ0)の場合はリトライ
  const w = canvas.clientWidth || canvas.width;
  const h = canvas.clientHeight || canvas.height;
  if(!w || !h){
    const n = (__sparklineAttempts.get(canvasId) || 0) + 1;
    if(n <= 8){
      __sparklineAttempts.set(canvasId, n);
      requestAnimationFrame(() => drawSparkline(canvasId, data));
    }
    return;
  }
  __sparklineAttempts.delete(canvasId);

  const raw = Array.isArray(data) ? data : [];
  const cleaned = raw.map(v => (typeof v === "number" && Number.isFinite(v)) ? v : null);
  const finite = cleaned.filter(v => v !== null);

  const ctx = canvas.getContext("2d");
  // 既存の描画をクリア
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if(finite.length < 2) return;

  const base = finite[0];                 // ベースライン（始値）
  const enableFill = finite.length >= 10; // 点数が少なすぎる時は線だけにする

  // ★グラデーションの作成（ここがポイント）
  // 上昇用（青）
  const gradUp = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradUp.addColorStop(0, 'rgba(30, 136, 229, 0.4)');  // 上部: 少し濃い青
  gradUp.addColorStop(1, 'rgba(30, 136, 229, 0.0)');  // 下部: 透明

// ▼ 修正箇所：下落用（赤）
  // 変更前：上（濃い）→ 下（透明）
  // 変更後：上（透明）→ 下（濃い）
  // これにより、暴落してグラフが下に行くほど「血が濃くなる（赤色がはっきりする）」ようになります。
  const gradDown = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradDown.addColorStop(0, 'rgba(211, 47, 47, 0.05)'); // 上（開始点付近）は薄く
  gradDown.addColorStop(1, 'rgba(211, 47, 47, 0.5)');  // 下（暴落の底）は濃く

  try{
    if(charts[canvasId]) charts[canvasId].destroy();

    charts[canvasId] = new Chart(ctx, {
      type: "line",
      data: {
        labels: cleaned.map((_, i) => i),
        datasets: [{
          data: cleaned,
          // 線自体の色（少し明るくして視認性を高める）
          borderColor: "rgba(255,255,255, 0.9)", 
          borderWidth: 1.5,
          pointRadius: 0,
          // 曲線にして滑らかさを出す（0:カクカク ～ 1:グニャグニャ）
          tension: 0.2, 

          // ★グラデーションを適用
          fill: enableFill ? {
            target: { value: base },
            above: gradUp,   // 始値より上なら青グラデ
            below: gradDown  // 始値より下なら赤グラデ
          } : false,

          backgroundColor: "rgba(0,0,0,0)",
          spanGaps: true
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false, // パフォーマンス優先
        plugins: { legend: { display:false }, tooltip: { enabled:false } },
        scales: { x: { display:false }, y: { display:false } },
        elements: {
          line: {
            borderJoinStyle: 'round', // 線の継ぎ目を丸くする
            capBezierPoints: true
          }
        }
      }
    });
  }catch(err){
    console.warn("sparkline render failed:", canvasId, err);
    try{ if(charts[canvasId]) charts[canvasId].destroy(); }catch{}
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
}

function buildSyntheticSparkline(coin){
  // Last-resort mini sparkline from 24h change (2 points) so the canvas is never blank.
  const p1 = (coin && typeof coin.current_price === 'number' && Number.isFinite(coin.current_price)) ? coin.current_price : null;
  const ch = (coin && typeof coin.price_change_percentage_24h === 'number' && Number.isFinite(coin.price_change_percentage_24h)) ? coin.price_change_percentage_24h : null;
  if(p1 === null || ch === null) return [];
  const denom = 1 + (ch / 100);
  if(!Number.isFinite(denom) || denom === 0) return [];
  const p0 = p1 / denom;
  if(!Number.isFinite(p0)) return [];
  return [p0, p1];
}

function hasAtLeast2Finite(arr){
  if(!Array.isArray(arr)) return false;
  let n = 0;
  for(const v of arr){
    if(typeof v === "number" && Number.isFinite(v)){
      n++;
      if(n >= 2) return true;
    }
  }
  return false;
}

// --- Sparkline fallback (when sparkline_in_7d is missing) ---
const __sparklineFallbackCache = new Map(); // coinId -> Promise<number[]>

function fetchSparkline7dFallback(coinId){
  if(!coinId) return Promise.resolve([]);
  if(__sparklineFallbackCache.has(coinId)) return __sparklineFallbackCache.get(coinId);
  const url = `https://api.coingecko.com/api/v3/coins/${encodeURIComponent(coinId)}/market_chart?vs_currency=jpy&days=7`;
  const p = fetchJsonRetry(url, { retries: 1 }).then(j => {
    const arr = (j && Array.isArray(j.prices)) ? j.prices.map(x => x && x[1]).filter(v => typeof v === "number") : [];
    return arr;
  }).catch(() => []);
  __sparklineFallbackCache.set(coinId, p);
  return p;
}

// --- Sparkline 24h (1d) for gainers/volume (keeps % change label consistent) ---
const __sparkline1dCache = new Map(); // coinId -> Promise<number[]>
function fetchSparkline1d(coinId){
  if(!coinId) return Promise.resolve([]);
  if(__sparkline1dCache.has(coinId)) return __sparkline1dCache.get(coinId);
  const url = `https://api.coingecko.com/api/v3/coins/${encodeURIComponent(coinId)}/market_chart?vs_currency=jpy&days=1`;
  const p = fetchJsonRetry(url, { retries: 1 }).then(j => {
    const arr = (j && Array.isArray(j.prices)) ? j.prices.map(x => x && x[1]).filter(v => typeof v === "number") : [];
    return arr;
  }).catch(() => []);
  __sparkline1dCache.set(coinId, p);
  return p;
}


  // 7日スパークラインから「直近24h相当」を切り出す（追加APIを減らして欠損を防ぐ）
  function derive24hFrom7d(spark7d) {
    if (!Array.isArray(spark7d)) return [];
    const len = spark7d.length;
    if (len <= 2) return spark7d;
    // 7日→24h は 1/7。Coingecko の sparkline はだいたい時間間隔が一定なので割合で切り出す
    const n = Math.max(12, Math.round(len / 7));
    return spark7d.slice(-Math.min(n, len));
  }


  function ensureChartjs(){ return (typeof Chart !== 'undefined'); }

  function computeRSISeries(prices, period = 14){
  // Wilder's RSI. Returns an array same length as prices (first values are null).
  if(!Array.isArray(prices) || prices.length < period + 1) return Array(prices?.length || 0).fill(null);

  const rsi = Array(prices.length).fill(null);

  let gainSum = 0;
  let lossSum = 0;
  for(let i=1;i<=period;i++){
    const diff = prices[i] - prices[i-1];
    if(diff >= 0) gainSum += diff; else lossSum += -diff;
  }
  let avgGain = gainSum / period;
  let avgLoss = lossSum / period;

  let rs = avgLoss === 0 ? Infinity : (avgGain / avgLoss);
  rsi[period] = 100 - (100 / (1 + rs));

  for(let i=period+1;i<prices.length;i++){
    const diff = prices[i] - prices[i-1];
    const gain = diff > 0 ? diff : 0;
    const loss = diff < 0 ? -diff : 0;

    avgGain = ((avgGain * (period - 1)) + gain) / period;
    avgLoss = ((avgLoss * (period - 1)) + loss) / period;

    rs = avgLoss === 0 ? Infinity : (avgGain / avgLoss);
    rsi[i] = 100 - (100 / (1 + rs));
  }
  return rsi;
}

function makeLineChart(canvasId, labels, series, opts){
    if (!ensureChartjs()) return;
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    // Prevent "Canvas is already in use" on refresh/re-render
    try { if (charts[canvasId]) charts[canvasId].destroy(); } catch(_){}
    try {
      if (typeof Chart !== 'undefined' && typeof Chart.getChart === 'function') {
        const existing = Chart.getChart(canvas);
        if (existing) existing.destroy();
      }
    } catch(_){}

    const datasets = (Array.isArray(series) ? series : []).map(s => ({
      label: s.label || '',
      data: Array.isArray(s.data) ? s.data : [],
      pointRadius: (s.pointRadius != null ? s.pointRadius : 0),
      borderWidth: (s.borderWidth != null ? s.borderWidth : 2),
      borderColor: (s.border != null ? s.border : (s.borderColor != null ? s.borderColor : "rgba(255,255,255,0.85)")),
      backgroundColor: (s.bg != null ? s.bg : (s.backgroundColor != null ? s.backgroundColor : 'rgba(255,255,255,0.06)')) ,
      tension: (s.tension != null ? s.tension : 0.25),
      fill: (s.fill != null ? s.fill : false),
      spanGaps: (s.spanGaps != null ? s.spanGaps : true),
      borderDash: (s.borderDash != null ? s.borderDash : undefined),
      order: (s.order != null ? s.order : 0)
    }));

    // Optional horizontal reference lines (e.g., RSI 30/70)
    const hLinePlugin = {
      id: 'hLines',
      afterDraw(chart, args, pluginOpts){
        // Chart.js v2 does not pass pluginOpts; fallback to chart options
        const o = (pluginOpts && Object.keys(pluginOpts).length)
          ? pluginOpts
          : ((chart && chart.options && chart.options.plugins && chart.options.plugins.hLines)
              || (chart && chart.config && chart.config.options && chart.config.options.plugins && chart.config.options.plugins.hLines)
              || {});
        const lines = Array.isArray(o.lines) ? o.lines : [];
        const values = Array.isArray(o.values) ? o.values : [];
        const items = lines.length ? lines : values.map(v => ({ value: v }));
        if (!items.length) return;
        const ctx = chart.ctx;

        // resolve y-scale across Chart.js versions
        let yScale = null;
        if (chart.scales){
          if (chart.scales.y && typeof chart.scales.y.getPixelForValue === 'function'){
            yScale = chart.scales.y;
          } else {
            const all = Object.values(chart.scales);
            yScale = all.find(s => (s && (s.axis === 'y' || String(s.id||'').startsWith('y')) && typeof s.getPixelForValue === 'function')) || null;
            if (!yScale) yScale = (chart.scales['y-axis-0'] || chart.scales['y0'] || null);
          }
        }
        if (!yScale || typeof yScale.getPixelForValue !== 'function') return;

        const area = chart.chartArea || { left: yScale.left, right: yScale.right, top: yScale.top, bottom: yScale.bottom };

        const left = area.left;
        const right = area.right;

        ctx.save();
        for (const it of items){
          const v = (it && it.value != null) ? it.value : it;
          const y = yScale.getPixelForValue(v);
          if (y >= area.top && y <= area.bottom){
            const color = (it && it.color) ? it.color : (o.color || 'rgba(255,255,255,0.28)');
            const width = (it && it.width != null) ? it.width : (o.width != null ? o.width : 1);
            const dash = Array.isArray(it && it.dash) ? it.dash : (Array.isArray(o.dash) ? o.dash : []);
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.setLineDash(dash);
            ctx.beginPath();
            ctx.moveTo(left, y);
            ctx.lineTo(right, y);
            ctx.stroke();
          }
        }
        ctx.restore();
      }
    };

    const yMin = (opts && opts.yMin != null ? opts.yMin : undefined);
    const yMax = (opts && opts.yMax != null ? opts.yMax : undefined);
    const beginAtZero = !!(opts && opts.yBeginAtZero);

    // Day grid (vertical separators) for 7d charts in MarketOverview
    const dayGrid = !!(opts && opts.dayGrid);
    const xGridColor = (opts && opts.xGridColor) ? opts.xGridColor : 'rgba(255,255,255,0.08)';
    const xGridWidth = (opts && opts.xGridWidth != null) ? opts.xGridWidth : 1;

    // Chart.js v2/v3+ options compatibility
    const v = (typeof Chart !== 'undefined' && Chart.version) ? String(Chart.version) : '';
    const isV2 = v.startsWith('2.');

    const options = {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      plugins: { legend: { display: false }, tooltip: { enabled: false }, hLines: (opts && opts.hLines) ? opts.hLines : {} }
    };

    if (isV2){
      options.scales = {
        xAxes: [{
          display: dayGrid ? true : false,
          ticks: { display:false, autoSkip:true, maxTicksLimit: 8 },
          gridLines: dayGrid ? { display:true, color: xGridColor, lineWidth: xGridWidth, drawBorder:false, drawTicks:false } : { display:false }
        }],
        yAxes: [{
          display:false,
          ticks: {
            beginAtZero: beginAtZero,
            min: yMin,
            max: yMax
          }
        }]
      };
    } else {
      options.scales = {
        x: {
          display: dayGrid ? true : false,
          ticks: { display:false, autoSkip:true, maxTicksLimit: 8 },
          grid: { display: dayGrid, color: xGridColor, lineWidth: xGridWidth, drawBorder:false }
        },
        y: {
          display:false,
          beginAtZero: beginAtZero,
          min: yMin,
          max: yMax
        }
      };
    }

    charts[canvasId] = new Chart(canvas, {
      type: 'line',
      data: { labels: labels, datasets: datasets },
      options,
      plugins: [hLinePlugin]
    });
  }

  // Sentiment gauge (0-100 => fear..greed). Render as a "filled" semi-gauge + needle.
  // Sentiment gauge (0-100) — SVG semi-gauge (mobile-safe)
  function buildSentimentGaugeSvg(score) {
    const svgNS = "http://www.w3.org/2000/svg";

    // clamp
    const s = Math.max(0, Math.min(100, Number(score) || 0));

    // --- geometry ---
    const cx = 120;
    const cy = 120;
    const r  = 90;
    const strokeW = 14;

    // 半円（左=180°, 右=0°）を 5分割で常時表示（赤→緑）
    const segments = [
      { a0: 180, a1: 144, color: "#ff4d4f" }, // 0-20
      { a0: 144, a1: 108, color: "#ff8f1f" }, // 20-40
      { a0: 108, a1: 72,  color: "#ffd43b" }, // 40-60
      { a0: 72,  a1: 36,  color: "#6ee7b7" }, // 60-80
      { a0: 36,  a1: 0,   color: "#22c55e" }, // 80-100
    ];

    // NOTE: SVGはY軸が下方向に増えるため、上向きの半円を描くには sin を反転する
    const polar = (deg) => {
      const rad = (deg * Math.PI) / 180;
      return [cx + r * Math.cos(rad), cy - r * Math.sin(rad)];
    };

    // 「上側の半円」を描くため sweep=1（順方向側）で統一（Y反転座標のため）
    const arcPath = (a0, a1) => {
      const [x0, y0] = polar(a0);
      const [x1, y1] = polar(a1);
      const largeArc = 0;
      const sweep = 1;
      return `M ${x0.toFixed(2)} ${y0.toFixed(2)} A ${r} ${r} 0 ${largeArc} ${sweep} ${x1.toFixed(2)} ${y1.toFixed(2)}`;
    };

    // svg root
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("class", "sent-gauge-svg");
    svg.setAttribute("viewBox", "0 0 240 140");
    svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

    // faint track（薄いベース）
    const track = document.createElementNS(svgNS, "path");
    track.setAttribute("d", arcPath(180, 0));
    track.setAttribute("fill", "none");
    track.setAttribute("stroke", "rgba(255,255,255,0.10)");
    track.setAttribute("stroke-width", String(strokeW));
    track.setAttribute("stroke-linecap", "round");
    svg.appendChild(track);

    // colored segments（常時表示）
    for (const seg of segments) {
      const p = document.createElementNS(svgNS, "path");
      p.setAttribute("d", arcPath(seg.a0, seg.a1));
      p.setAttribute("fill", "none");
      p.setAttribute("stroke", seg.color);
      p.setAttribute("stroke-width", String(strokeW));
      p.setAttribute("stroke-linecap", "round");
      svg.appendChild(p);
    }

    // needle（0=左, 100=右）
    const ang = 180 - (s / 100) * 180; // deg
    const rad = (ang * Math.PI) / 180;
    const nr = r - 18;
    const nx = cx + nr * Math.cos(rad);
    const ny = cy - nr * Math.sin(rad);

    const needle = document.createElementNS(svgNS, "line");
    needle.setAttribute("x1", String(cx));
    needle.setAttribute("y1", String(cy));
    needle.setAttribute("x2", String(nx.toFixed(2)));
    needle.setAttribute("y2", String(ny.toFixed(2)));
    needle.setAttribute("stroke", "rgba(229,231,235,0.95)");
    needle.setAttribute("stroke-width", "2.5");
    needle.setAttribute("stroke-linecap", "round");
    svg.appendChild(needle);

    const hub = document.createElementNS(svgNS, "circle");
    hub.setAttribute("cx", String(cx));
    hub.setAttribute("cy", String(cy));
    hub.setAttribute("r", "4");
    hub.setAttribute("fill", "rgba(229,231,235,0.95)");
    svg.appendChild(hub);

    return svg;
  }

  function updateSentimentGauge(score, labelText) {
    const oldSvg = document.querySelector(".sent-gauge svg.sent-gauge-svg");
    if (oldSvg) {
      const newSvg = buildSentimentGaugeSvg(score);
      oldSvg.parentNode.replaceChild(newSvg, oldSvg);
    }

    // CSS needle is deprecated (SVG needle is used).
    const cssNeedle = document.getElementById('sentNeedle');
    if (cssNeedle) cssNeedle.style.display = 'none';

    // Update label text on the card
    const lb = document.getElementById('sentLabel');
    if (lb && labelText != null) lb.textContent = String(labelText);
  }

  function makeBaselineChart(canvasId, labels, dataArr, opts){
    if (!ensureChartjs()) return;
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    // 既存チャートがあると Chart.js が "Canvas is already in use" を投げるため、必ず破棄してから再生成する
    try {
      if (charts && charts[canvasId]) {
        charts[canvasId].destroy();
        delete charts[canvasId];
      }
    } catch(_e){}

    try {
      if (typeof Chart !== 'undefined' && typeof Chart.getChart === 'function') {
        const existing = Chart.getChart(canvas);
        if (existing) existing.destroy();
      }
    } catch(_e){}

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const dayGrid = !!(opts && opts.dayGrid);
    const xGridColor = (opts && opts.xGridColor) ? opts.xGridColor : 'rgba(255,255,255,0.08)';
    const xGridWidth = (opts && opts.xGridWidth != null) ? opts.xGridWidth : 1;

    charts[canvasId] = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          data: dataArr,
          pointRadius: 0,
          borderWidth: 2,
          borderColor: '#e5e7eb',
          tension: 0.25,
          fill: {
            target: { value: 0 },
            above: 'rgba(30, 136, 229, 0.22)',
            below: 'rgba(211, 47, 47, 0.22)'
          }
        }]
      },
      options: {
        responsive:true, maintainAspectRatio:false, animation:false,
        plugins:{ legend:{display:false}, tooltip:{enabled:false} },
        scales:{ x:{ display: dayGrid ? true : false, ticks:{display:false, autoSkip:true, maxTicksLimit:8}, grid:{ display: dayGrid, color: xGridColor, lineWidth: xGridWidth, drawBorder:false } }, y:{display:false} }
      }
    });
  }

  function makeNormalizedLine(canvasId, labels, dataArr, opts){
    if (!ensureChartjs()) return;
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    // 非表示のキャンバスは描画しない（統合カード等で使用）
    try{
      const st = window.getComputedStyle(canvas);
      if (st && st.display === 'none') return;
    } catch(_){}
// データに NaN / Infinity が混ざると描画が崩れることがあるので、ここでサニタイズ
    const clean = (dataArr || []).map(v => (Number.isFinite(v) ? v : 0));
    const last = clean.length ? clean[clean.length - 1] : 0;
    const norm = (Number.isFinite(last) && last !== 0)
      ? clean.map(v => (v / last) * 100)
      : clean.map(_ => 0);

    // 既存チャートがあれば破棄してから作り直す
    if (charts[canvasId]) { try { charts[canvasId].destroy(); } catch(_){} }

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const dayGrid = !!(opts && opts.dayGrid);
    const xGridColor = (opts && opts.xGridColor) ? opts.xGridColor : 'rgba(255,255,255,0.08)';
    const xGridWidth = (opts && opts.xGridWidth != null) ? opts.xGridWidth : 1;

    charts[canvasId] = new Chart(ctx, {
      type:'line',
      data:{ labels: labels, datasets:[{
        data: norm,
        pointRadius:0,
        borderWidth:2,
        borderColor:'#e5e7eb',
        tension:0.25,
        fill:false,
        spanGaps:true
      }]},
      options:{ responsive:true, maintainAspectRatio:false, animation:false,
        plugins:{ legend:{display:false}, tooltip:{enabled:false} },
        scales:{ x:{ display: dayGrid ? true : false, ticks:{display:false, autoSkip:true, maxTicksLimit:8}, grid:{ display: dayGrid, color: xGridColor, lineWidth: xGridWidth, drawBorder:false } }, y:{display:false} }
      }
    });
  }

// 安全なカード生成関数（3行コンパクト・画像最適化・レンジバー削除版）
  function renderInto(gridId, coins, mode, sectionKey){
    const grid = document.getElementById(gridId);
    if(!grid) return;
    grid.innerHTML = '';

    if (!coins || !coins.length){
      const hasError = (typeof SECTION_ERRORS !== 'undefined' && SECTION_ERRORS.trend);
      if (sectionKey === 'trend' && hasError){
        grid.innerHTML = '<div class="msg">トレンドの取得に失敗しました（他のデータは表示しています）。時間をおいて再読み込みしてください。</div>';
        return;
      }
      grid.innerHTML = '<div class="msg">最新データの取得が遅れています。時間をおいて再読み込みしてください。</div>';
      return;
    }

    coins.forEach((coin, idx) => {
      const change = coin.price_change_percentage_24h;
      const trendClass = (typeof change === 'number') ? (change >= 0 ? 'up' : 'down') : '';
      const changeClass = (typeof change === 'number') ? (change >= 0 ? 'positive' : 'negative') : '';

      const card = document.createElement('div');
      card.className = `card ${trendClass}`;
      
      card.dataset.coinId = (coin && coin.id) ? coin.id : '';
      card.dataset.sectionKey = sectionKey;
      
      const placementMap = {
        trend: 'index_card_trend',
        gainers: 'index_card_gainers',
        volume: 'index_card_volume',
        mcap: 'index_card_mcap'
      };
      const placement = placementMap[sectionKey] || `index_card_${sectionKey}`;

      card.onclick = () => {
        const url = coinGeckoUrlFor(coin);
        if (typeof fireCtaClick === 'function') {
          fireCtaClick({
            cta_id: 'card_open',
            placement,
            partner: 'coingecko',
            pr: 0,
            link_url: url
          });
        }
        window.open(url, '_blank', 'noopener');
      };

      const rankCls = idx===0 ? 'rank-1' : idx===1 ? 'rank-2' : idx===2 ? 'rank-3' : '';

      const pctText = (typeof change === 'number')
        ? ((change>=0?'+':'') + change.toFixed(2) + '%')
        : '-';

      // 1. シンボルの横に置くランクバッジ
      const globalRankHtml = (coin.market_cap_rank && mode !== 'mcap') 
        ? `<span style="background:rgba(255,255,255,0.1); padding:0 4px; border-radius:3px; margin-left:4px; font-size:10px; color:#cbd5e1;">#${coin.market_cap_rank}</span>` 
        : '';

      // 2. KPI行
      let turnoverBadge = '';
      if (typeof coin.total_volume === 'number' && typeof coin.market_cap === 'number' && coin.market_cap > 0) {
        const rate = (coin.total_volume / coin.market_cap) * 100;
        // ラベル「回転率」を追加
        turnoverBadge = `<span class="meta-badge" title="24h出来高÷時価総額：市場の活発さ">回転率 ${rate.toFixed(1)}%</span>`;
      }

      let athBadge = '';
      if (typeof coin.ath_change_percentage === 'number') {
        const ath = coin.ath_change_percentage;
        // ラベル「ATH比」を追加
        athBadge = `<span class="meta-badge" title="過去最高値からの下落率">ATH比 ${ath.toFixed(1)}%</span>`;
      }

      let mainMetricHtml = '';
      if (mode === 'mcap') {
        mainMetricHtml = `<span class="meta-val">Cap ${yenLarge(coin.market_cap)}</span>`;
      } else {
        const val = (typeof coin.total_volume === 'number') ? yenLarge(coin.total_volume) : '-';
        mainMetricHtml = `<span class="meta-val">Vol ${val}</span>`;
      }

      const kpiLineHtml = `<div class="meta-row" style="flex-wrap:wrap; justify-content:flex-end; gap:6px;">${mainMetricHtml} ${turnoverBadge} ${athBadge}</div>`;

      const canvasId = `sp_${sectionKey}_${(coin.id || coin.symbol || idx)}`;

      // HTML生成（画像最適化入り）
      card.innerHTML = `
        <div class="rank-badge ${rankCls}">#${idx+1}</div>
        <div class="card-header">
          <div class="coin-header">
            <img class="coin-icon" src="${coin.image}" alt="${coin.name}" loading="lazy" onerror="this.onerror=null; this.style.display='none'; this.nextElementSibling.style.display='flex';">
            <div class="coin-icon-fallback" style="display:none;">${(coin.symbol||'?').charAt(0).toUpperCase()}</div>
            <div>
              <div class="coin-name">${coin.name}</div>
              <div class="coin-symbol">${(coin.symbol||'').toUpperCase()}${globalRankHtml}</div>
            </div>
          </div>
          <div>
            <div class="price">${yen(coin.current_price)}</div>
            <div class="change ${changeClass}">24h: ${pctText}</div>
            ${kpiLineHtml}
          </div>
        </div>
        <canvas id="${canvasId}" class="sparkline" aria-label="price chart" role="img"></canvas>
      `;

      grid.appendChild(card);

      // Sparkline
      if (mode==='mcap' && !(coin && coin.sparkline_in_7d && Array.isArray(coin.sparkline_in_7d.price) && coin.sparkline_in_7d.price.length)){
        return;
      }
      const ensureSparklineLater = () => {
        setTimeout(() => {
          try{
            if (!charts[canvasId]){
              const syn = buildSyntheticSparkline(coin);
              if (hasAtLeast2Finite(syn)) drawSparkline(canvasId, syn);
            }
          }catch(_e){}
        }, 600);
      };

      try{
        const use24h = (sectionKey === 'gainers' || sectionKey === 'volume');
        if (use24h){
          const sp7 = coin?.sparkline_in_7d?.price;
          const sp24 = derive24hFrom7d(sp7);
          if (hasAtLeast2Finite(sp24)) {
            drawSparkline(canvasId, sp24);
          } else {
            const syn0 = buildSyntheticSparkline(coin);
            if (hasAtLeast2Finite(syn0)) drawSparkline(canvasId, syn0);
            fetchSparkline1d(coin.id).then(arr => {
              if (hasAtLeast2Finite(arr)) drawSparkline(canvasId, arr);
            }).catch(() => {});
          }
        } else {
          const sp = coin?.sparkline_in_7d?.price;
          drawSparkline(canvasId, sp);
          if (!hasAtLeast2Finite(sp)) {
            const syn0 = buildSyntheticSparkline(coin);
            if (hasAtLeast2Finite(syn0)) drawSparkline(canvasId, syn0);
            fetchSparkline7dFallback(coin.id).then(arr => {
              if (hasAtLeast2Finite(arr)) drawSparkline(canvasId, arr);
            }).catch(() => {});
          }
        }
      } catch(e){
        console.warn('sparkline failed:', coin?.id || coin?.symbol || idx, e);
        const syn = buildSyntheticSparkline(coin);
        if (hasAtLeast2Finite(syn)) drawSparkline(canvasId, syn);
      }
      ensureSparklineLater();
    });
  }
  
  function renderQuickSummary(){
    const rankIcon = (i)=> (i===0?'🥇':(i===1?'🥈':(i===2?'🥉':String(i+1))));
    const pctText = (n)=>{
      if (typeof n !== 'number' || !isFinite(n)) return '—';
      return (n>=0?'+':'') + n.toFixed(2) + '%';
    };
    const safeTxt = (s)=> (s==null || s==='') ? '—' : String(s);

    const esc = (s)=>{
      try{ return (window.CSS && CSS.escape) ? CSS.escape(s) : String(s).replace(/["\\]/g,''); }
      catch(_){ return String(s); }
    };

    function openCoinGecko(coin){
      const url = coinGeckoUrlFor(coin);
      try{
        fireCtaClick({
          cta_id: 'summary_open',
          placement: 'index_summary',
          partner: 'coingecko',
          pr: 0,
          link_url: url
        });
      }catch(_){}
      window.open(url, '_blank', 'noopener');
    }

    function scrollToCoin(gridId, coin){
      const grid = document.getElementById(gridId);
      if (!grid) return;
      const cid = (coin && coin.id) ? coin.id : '';
      let card = cid ? grid.querySelector(`[data-coin-id="${esc(cid)}"]`) : null;
      if (!card) card = grid.querySelector('.card');
      if (!card) return;
      card.scrollIntoView({ behavior:'smooth', block:'center' });
      card.classList.add('flash');
      setTimeout(()=>{ try{ card.classList.remove('flash'); }catch(_e){} }, 1300);
    }

    function fillList(listId, coins, gridId){
      const ol = document.getElementById(listId);
      if (!ol) return;
      ol.innerHTML = '';

      if (!coins || !coins.length){
        const li = document.createElement('li');
        li.className = 'summary-li muted';
        li.textContent = '—';
        ol.appendChild(li);
        return;
      }

      coins.slice(0,5).forEach((coin, idx)=>{
        const li = document.createElement('li');
        li.className = 'summary-li clickable';

        const left = document.createElement('span');
        left.className = 'summary-left';

        const r = document.createElement('span');
        r.className = 'summary-rank';
        r.textContent = rankIcon(idx);

        const sym = document.createElement('span');
        sym.className = 'summary-symbol';
        sym.textContent = safeTxt((coin.symbol || '').toUpperCase() || coin.name || coin.id);

        left.appendChild(r);
        left.appendChild(sym);

        const wrap = document.createElement('span');
        wrap.className = 'summary-right-wrap';

        const pct = document.createElement('span');
        const chg = coin.price_change_percentage_24h;
        pct.className = 'summary-right ' + ((typeof chg === 'number') ? (chg>=0?'positive':'negative') : '');
        pct.textContent = pctText(chg);

        const ext = document.createElement('span');
        ext.className = 'summary-ext';
        ext.title = 'CoinGeckoで開く';
        ext.textContent = '↗';
        ext.onclick = (ev)=>{
          ev.stopPropagation();
          openCoinGecko(coin);
        };

        wrap.appendChild(pct);
        wrap.appendChild(ext);

        li.appendChild(left);
        li.appendChild(wrap);

        // main click: scroll to the detailed section/card (keep user on site)
        li.onclick = ()=>{
          scrollToCoin(gridId, coin);
        };

        ol.appendChild(li);
      });
    }

    fillList('summaryTrendList', trendingCoins, 'grid-trend');
    fillList('summaryUpList', getGainersTop5(), 'grid-gainers');
    fillList('summaryVolAltList', getAltVolumeTop5(), 'grid-alt-volume');
  }

// ▼▼▼ 修正版：7日比（週間変動率）を追加したテーブル描画 ▼▼▼
function renderRankTable(coins) {
  const tbody = document.getElementById('mcapTableBody');
  if (!tbody) return;
  tbody.innerHTML = '';

  if (!coins || !coins.length) {
    tbody.innerHTML = '<tr><td colspan="8" style="padding:20px;text-align:center;color:#64748b;">データ取得中...</td></tr>';
    return;
  }

  coins.forEach((c, i) => {
    // データ整形
    const price = yen(c.current_price);
    const mcap = yenLarge(c.market_cap);
    const vol = yenLarge(c.total_volume);
    
    // 24時間比
    const chg24 = c.price_change_percentage_24h;
    const chg24Class = (chg24 >= 0) ? 'text-up' : 'text-down';
    const chg24Str = (typeof chg24 === 'number') ? (chg24 > 0 ? '+' : '') + chg24.toFixed(1) + '%' : '-';

    // ★追加：7日比
    // APIから "price_change_percentage_7d_in_currency" という名前でデータが来ます
    const chg7d = c.price_change_percentage_7d_in_currency;
    const chg7dClass = (chg7d >= 0) ? 'text-up' : 'text-down';
    const chg7dStr = (typeof chg7d === 'number') ? (chg7d > 0 ? '+' : '') + chg7d.toFixed(1) + '%' : '-';

    // RSI計算
    let rsiVal = null, rsiClass = '';
    let sparkData = [];
    if (c.sparkline_in_7d && c.sparkline_in_7d.price) {
      sparkData = c.sparkline_in_7d.price;
      const series = computeRSISeries(sparkData);
      const last = series[series.length - 1];
      if (last) {
        rsiVal = Math.round(last);
        if (rsiVal >= 70) rsiClass = 'rsi-high';
        else if (rsiVal <= 30) rsiClass = 'rsi-low';
      }
    }
    // バッジのHTML生成
    const rsiHtml = rsiVal !== null 
      ? `<span class="rsi-badge ${rsiClass}">${rsiVal}</span>` 
      : `<span class="rsi-badge">—</span>`;

    const canvasId = `tbl_chart_${c.id}_${i}`;

    // --- テーブル行（TR）の生成部分 ---
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="td-sym">
        <div class="sym-wrap">
          <span class="sym-rank">${i + 1}</span>
          <img class="sym-icon" src="${c.image}" loading="lazy" alt="">
          <span class="sym-code">${c.symbol.toUpperCase()}</span>
        </div>
      </td>
      <td>${price}</td>
      <td class="${chg24Class}">${chg24Str}</td> 
      <td class="${chg7dClass}">${chg7dStr}</td> 
      <td>${mcap}</td> 
      <td class="td-rsi">${rsiHtml}</td> <td class="td-chart"><canvas id="${canvasId}"></canvas></td>
      <td>${vol}</td>
    `;
    
    tr.style.cursor = 'pointer';
    tr.onclick = () => window.open(coinGeckoUrlFor(c), '_blank');
    tbody.appendChild(tr);

    setTimeout(() => {
      if (sparkData.length > 0) drawSparkline(canvasId, sparkData);
    }, 0);
  });
}

function renderAll(){
    clearCharts();
    renderInto('grid-trend', trendingCoins, 'trend', 'trend');
    renderInto('grid-gainers', getGainersTop5(), 'gainers', 'gainers');
    renderInto('grid-volume', getVolumeTop5(), 'volume', 'volume');
    renderInto('grid-alt-volume', getAltVolumeTop5(), 'alt_volume', 'alt_volume');
    renderRankTable(getMarketCapTop20());
    renderOverview();
    try{ renderQuickSummary(); }catch(e){ console.warn("quick summary failed", e); }
    // ★追加：ブラウザのタブタイトルを動的に更新（BTC価格とトレンド）
    updateDynamicTitle();
    // ▼▼▼ 追加：AI分析を実行 ▼▼▼
    try { updateAiInsight(); } catch(e){ console.warn("AI insight failed", e); }
    // ▲▲▲ 追加ここまで ▲▲▲
  }
  // ★追加：タイトル更新関数
  function updateDynamicTitle(){
    // BTCを探す
    const btc = marketsTop.find(c => c.id === 'bitcoin');
    if(!btc) return;

    const price = (btc.current_price / 10000).toFixed(0) + '万'; // "1352万"
    const change = btc.price_change_percentage_24h;
    const sign = (change >= 0) ? '+' : '';
    const chgText = (typeof change === 'number') ? `(${sign}${change.toFixed(1)}%)` : '';

    // タブタイトルを書き換え
    document.title = `BTC ¥${price} ${chgText} | CoinRader`;
  }
  // ▼ 修正：スケルトン表示用のHTML生成関数
  function getSkeletonHTML(count = 5) {
    return Array(count).fill(0).map(() => `
      <div class="skeleton sk-card">
        <div class="sk-header">
          <div class="sk-circle"></div>
          <div class="sk-lines">
            <div class="sk-bar sk-w-40"></div>
            <div class="sk-bar sk-w-30"></div>
          </div>
        </div>
        <div class="sk-bottom">
          <div class="sk-bar sk-w-40"></div>
          <div class="sk-bar sk-w-60"></div>
        </div>
      </div>
    `).join('');
  }

  function setLoadingAll(){
    const html = getSkeletonHTML(5);
    const grids = ['grid-trend', 'grid-gainers', 'grid-volume', 'grid-alt-volume', 'grid-mcap'];
    grids.forEach(id => {
      const el = document.getElementById(id);
      if(el) el.innerHTML = html;
    });

    const om = document.getElementById('overviewMsg');
    if (om){ om.style.display='none'; om.textContent=''; }
  }
  // ===== Refresh UI (auto/manual refresh without flicker) =====
  let HAS_RENDERED_ONCE = false;

  const SECTION_ERRORS = { trend:false };
  function resetSectionErrors(){ SECTION_ERRORS.trend=false; }

  function setRefreshingAll(on){
    const ids = ['grid-trend','grid-gainers','grid-volume','grid-alt-volume','grid-mcap'];
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.classList.toggle('refreshing', !!on);
    });
  }
// ▼▼▼ 追加：スマホ用サイドメニューの開閉処理 ▼▼▼
// ▼▼▼ 修正版：スマホ用サイドメニュー（リンククリックで確実に閉じる機能を追加） ▼▼▼
function setupSideMenu() {
  const btn = document.getElementById('menuBtn');
  const menu = document.getElementById('sideMenu');
  const overlay = document.getElementById('sideMenuOverlay');
  const closeBtn = document.getElementById('menuCloseBtn');
  
  if (!btn || !menu || !overlay) return;

  // 開閉の動きを管理する関数
  const toggle = (open) => {
    if (open) {
      menu.classList.add('is-open');
      overlay.hidden = false;
      overlay.style.display = 'block';
      btn.setAttribute('aria-expanded', 'true');
      menu.setAttribute('aria-hidden', 'false');
    } else {
      menu.classList.remove('is-open');
      // ここで確実に黒い背景を消す
      overlay.hidden = true;
      overlay.style.display = 'none';
      btn.setAttribute('aria-expanded', 'false');
      menu.setAttribute('aria-hidden', 'true');
    }
  };

  btn.addEventListener('click', () => toggle(true));
  if (closeBtn) closeBtn.addEventListener('click', () => toggle(false));
  
  // 背景クリックで閉じる
  overlay.addEventListener('click', () => toggle(false));

  // ★追加：メニュー内のリンク（始め方など）を押した時も、強制的にメニューを閉じる
  const links = menu.querySelectorAll('.sideNavLink');
  links.forEach(link => {
    link.addEventListener('click', () => {
      toggle(false); // メニューと黒背景をOFFにする
    });
  });
}

// --- 1. 補助関数: タイピング演出 (HTMLタグ対応) ---
async function typeWriter(el, html, speed = 20) {
    el.classList.add('typing');
    const temp = document.createElement('div');
    temp.innerHTML = html;
    const nodes = Array.from(temp.childNodes);
    el.innerHTML = '';

    for (const node of nodes) {
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent;
            for (let i = 0; i < text.length; i++) {
                el.innerHTML += text[i];
                await new Promise(r => setTimeout(r, speed));
            }
        } else {
            const clone = node.cloneNode(false);
            el.appendChild(clone);
            if (node.childNodes.length > 0) {
                await typeWriter(clone, node.innerHTML, speed);
            }
        }
    }
    el.classList.remove('typing');
}

// --- 1.5 過去の分析データを安全に取得する関数 (新旧形式対応) ---
async function getHistoricalData(daysAgo = 7) {
    const now = new Date();
    const formatDate = (d) => {
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return `${y}${m}${day}`;
    };

    const targetDate = new Date(now);
    targetDate.setDate(now.getDate() - daysAgo);

    // 取得候補：1. 指定日数前、2. 蓄積開始日(20260126)
    const filenames = [formatDate(targetDate), "20260126"];
    
    for (const dateStr of filenames) {
        try {
            const res = await fetch(`data/daily/${dateStr}.json`);
            if (res.ok) {
                const json = await res.json();
                // 20260128以降の新形式(summaryあり)か、20260126の旧形式かを判定
                const s = json.summary || {}; 
                
                return {
                    date: s.date || json.date || dateStr,
                    // FGI/RSIは旧形式には存在しないため null を返す
                    fgi: (s.fgi && s.fgi.value !== undefined) ? s.fgi.value : null,
                    dom: s.btc_dominance !== undefined ? s.btc_dominance : null,
                    rsi: (s.technical && s.technical.btc_rsi) ? s.technical.btc_rsi : null
                };
            }
        } catch (e) { continue; }
    }
    return null;
}

// --- 2. メイン関数: AI分析 ＆ 再描画抑止 ＆ 過去比較ロジック ---
let _aiThinking = false;
let _lastAiState = ""; 

async function updateAiInsight() {
    const box = document.getElementById('aiInsightBox');
    const textEl = document.getElementById('aiInsightText');
    const timeEl = document.getElementById('aiUpdateTime'); // ここで取得
    if (!box || !textEl || _aiThinking) return;

    const sentTxt = document.getElementById('sumSentMain')?.textContent || "";
    const rsiTxt = document.getElementById('sumRsiMain')?.textContent || "";
    const domTxt = document.getElementById('sumDomMain')?.textContent || "";
    const maTxt = document.getElementById('sumMaMain')?.textContent || "";

    if (sentTxt.includes('—') || !sentTxt) return;

    const currentState = `${sentTxt}|${rsiTxt}|${domTxt}|${maTxt}`;
    if (_lastAiState === currentState) return;

    const sent = parseFloat(sentTxt);
    const rsi = parseFloat(rsiTxt);
    const dom = parseFloat(domTxt);
    const maDist = parseFloat(maTxt) || 0;

    _aiThinking = true;
    _lastAiState = currentState;

    // ★ 1. 解析開始と同時に「ANALYZING...」と表示させる
    if (timeEl) timeEl.textContent = "[ ANALYZING... ]";

    // A. 思考中演出（砂時計を完全に排除）
    textEl.innerHTML = `
      <div class="ai-loading-placeholder" style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:140px; width:100%; gap:15px;">
        <div class="cyber-loader">
          <div class="cyber-dot"></div>
        </div>
        <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
          <span style="font-family:monospace; color:#38bdf8; font-size:10px; opacity:0.9; letter-spacing:2px; animation: pulse 1.5s infinite;">SYSTEM.ANALYZING...</span>
          <span style="color:#64748b; font-size:11px; font-weight:500;">市場構造をスキャン中</span>
        </div>
      </div>`;

    await new Promise(r => setTimeout(r, 1500));

    // --- B. 過去比較の実行 ---
    const past = await getHistoricalData(7);
    let comparisonText = "";

    if (past) {
        // FGIの比較（20260126の場合はデータがないのでスキップされる）
        if (past.fgi !== null) {
            const fgiDiff = sent - past.fgi;
            if (fgiDiff >= 15) comparisonText += `数日前（${past.date}）に比べ<strong>市場心理が大きく好転</strong>しています。`;
            else if (fgiDiff <= -15) comparisonText += `直近と比較して<strong>警戒感が強まって</strong>います。`;
        }
        
        // ドミナンスの比較（旧形式でも数値があれば実行）
        if (past.dom !== null) {
            const domDiff = dom - past.dom;
            if (domDiff < -0.8) comparisonText += `BTCドミナンスの低下により、資金が<strong>アルト銘柄へ分散する傾向</strong>が見られます。`;
        }

        // RSIの比較（データがある場合のみ）
        if (rsi && past.rsi !== null) {
            const rsiDiff = rsi - past.rsi;
            if (Math.abs(rsiDiff) > 20) comparisonText += `RSIの急変により、短期的な<strong>需給の転換点</strong>を迎えています。`;
        }
    }

// --- C. 客観・多角分析ロジック (指示・推奨文言の排除) ---
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    
    const isExtremeGreed = sent >= 80;
    const isExtremeFear = sent <= 20;
    const isOverbought = rsi >= 70;
    const isOversold = rsi <= 30;
    const isTrendUp = maDist > 0;
    const isOverExtended = Math.abs(maDist) > 10; 
    const isAltRotation = dom < 52;

    let strategyText = "";

    // 1. 極端な市場状態
    if (isExtremeGreed && isOverbought) {
        strategyText = pick([
            `主要な技術指標が軒並み高位に達しており、市場は<strong>「統計的限界域」</strong>での推移を続けています。過熱したセンチメントを背景に、現在の価格帯を維持するための強い買い支えが試される局面です。`,
            `心理的・テクニカル面で強い過熱感が確認されます。<strong>「一方向への偏り」</strong>が顕著となっており、小さな需給の変化が価格変動を増幅させやすい非対称な構造となっています。`
        ]);
    } else if (isExtremeFear && isOversold) {
        strategyText = pick([
            `投資家心理が極端な悲観に振れており、データ上は<strong>「パニック的な需給の歪み」</strong>が観測されます。売り圧力が極大化している一方で、技術的な反発エネルギーも蓄積されつつあるフェーズです。`,
            `市場構造に<strong>「投げ売りの兆候」</strong>が見られます。短期的な流動性が枯渇気味となっており、需給の再均衡に向けた「底値探り」のプロセスにあることを示唆しています。`
        ]);

    // 2. トレンドの乖離
    } else if (isTrendUp && isOverExtended) {
        strategyText = pick([
            `移動平均線からの乖離率が拡大しており、<strong>トレンドの「伸び切り」</strong>が鮮明です。価格推移のペースが過去の平均を大きく上回っており、テクニカル的な自律調整が発生しやすい水準にあります。`,
            `短期的なオーバーシュート（行き過ぎ）が意識される価格帯です。<strong>トレンドの勢い</strong>は維持されているものの、歴史的な乖離水準にあり、モメンタムの持続性が今後の焦点となります。`
        ]);

    // 3. 資金循環
    } else if (isAltRotation && isTrendUp) {
        strategyText = pick([
            `BTCドミナンスの低下と共に、資金がアルト市場へ分散する<strong>「セクターローテーション」</strong>の動きが確認できます。リスク許容度の高まりを背景に、市場全体の流動性が多角化している構図です。`,
            `主要銘柄から中小型銘柄への<strong>資金還流（循環物色）</strong>が起きています。ビットコインの支配力が和らぎ、アルトコインのボラティリティが市場全体の時価総額を押し上げるフェーズにあります。`
        ]);

    // 4. 均衡・停滞
    } else if (sent > 40 && sent < 60 && !isOverbought && !isOversold) {
        strategyText = pick([
            `主要指標に明確な偏りはなく、<strong>「需給の均衡状態」</strong>が続いています。ボラティリティが収束しており、次なる市場材料によるブレイクアウトを待つパワー蓄積の期間となっています。`,
            `市場参加者のコンセンサスが分散し、方向感を欠く<strong>「レンジ内推移」</strong>にあります。各指標が中立圏に収まっており、新たな需給のトレンドが発生する予兆を注視する時間帯です。`
        ]);

    // 5. 弱気構造
    } else if (!isTrendUp) {
        strategyText = pick([
            `主要な移動平均線を下回って推移しており、<strong>構造的な弱気地合い</strong>が継続しています。反発が発生しても供給（戻り売り）が強く、市場構造の転換を確認するには、主要指標の好転が必要な状態です。`,
            `流動性が低下し、市場参加者の多くが<strong>「慎重な姿勢」</strong>を維持しています。価格の魅力よりも下押しリスクが重く意識されており、指標の安定化に向けた模索が続いています。`
        ]);

    // 6. デフォルト
    } else {
        strategyText = `市場構造は緩やかな変化の中にあり、特定の指標に極端な偏りは見られません。<strong>「個別銘柄の材料視」</strong>が優先される地合いとなっており、構造的なトレンドの発生を待機している状態です。`;
    }

    // D. タイピング演出（比較文 + メイン文）
    const finalHtml = (comparisonText ? comparisonText + "<br><br>" : "") + strategyText;
    await typeWriter(textEl, finalHtml, 20);

    // E. エビデンス表示
    const getTag = (val, type) => {
        if (type === 'rsi') {
            if (val >= 70) return `<span style="color:#f87171;font-weight:700;">過熱 (${val})</span>`;
            if (val <= 30) return `<span style="color:#60a5fa;font-weight:700;">売られすぎ (${val})</span>`;
            return `<span style="color:#94a3b8;">中立 (${val})</span>`;
        }
        if (type === 'sent') {
            if (val >= 75) return `<span style="color:#4ade80;font-weight:700;">楽観 (${val})</span>`;
            if (val <= 25) return `<span style="color:#f87171;font-weight:700;">悲観 (${val})</span>`;
            return `<span style="color:#94a3b8;">中立 (${val})</span>`;
        }
        return val;
    };

    const evidenceHtml = `
      <div class="ai-evidence-grid" style="opacity:0; transition: opacity 1s ease; margin-top:12px !important; background:rgba(0,0,0,0.25); border-radius:10px; padding:10px !important; border:1px solid rgba(255,255,255,0.05);">
        <div style="font-size:10px; color:#64748b; margin-bottom:10px; font-weight:700; text-transform:uppercase; letter-spacing:0.1em; display:flex; align-items:center; gap:6px;">
          <span style="width:12px; height:1px; background:#64748b;"></span> 多角的な分析エビデンス
        </div>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px 15px; font-size:12px;">
          <div style="color:#94a3b8;">投資家心理: ${getTag(sent, 'sent')}</div>
          <div style="color:#94a3b8;">短期勢い: ${getTag(rsi, 'rsi')}</div>
          <div style="color:#94a3b8;">資金の偏り: <span style="color:#e2e8f0">${dom < 53 ? 'アルト分散' : 'BTC集中'} (${dom.toFixed(1)}%)</span></div>
          <div style="color:#94a3b8;">トレンド構造: <span style="color:#e2e8f0">${maDist.toFixed(1)}%</span></div>
        </div>
      </div>`;

    textEl.innerHTML += evidenceHtml;
    setTimeout(() => {
        const grid = textEl.querySelector('.ai-evidence-grid');
        if (grid) grid.style.opacity = '1';
    }, 100);

    const now = new Date();
    const timeStr = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
    if (timeEl) {
        timeEl.textContent = `[ ANALYZED AT ${timeStr} ]`;
        timeEl.style.opacity = "1"; // 完了したら少し明るくする
    }
    _aiThinking = false;
}
  
  // ============ Boot ============
  async function init(fromManualRefresh=false){
    const firstLoad = !HAS_RENDERED_ONCE;
    if (firstLoad) {
      setLoadingAll();
      resetSectionErrors();
    } else {
      setRefreshingAll(true);
      // 「更新中」ではなく、よりポジティブな「同期中」に統一
      if (!IN_AUTO_REFRESH) setStatus('最新データと同期中…');
    }

    try{
      // 内部的な「〇〇取得中」の小刻みな書き換えを止め、同期中に統一
      if (firstLoad) setStatus('最新データと同期中…');
      await loadMarketsTop250(fromManualRefresh);

      // 追加KPI: BTC MAクロス距離
      try{ await loadBtcMaCross(); }catch(e){ window.__btcMaCross = null; }

      if (!marketsTop.length){
        setStatus('接続待機中');
        document.getElementById('grid-mcap').innerHTML = '<div class="msg">データの取得が遅れています。時間をおいて再読み込みしてください。</div>';
        document.getElementById('grid-trend').innerHTML = '<div class="msg">---</div>';
        document.getElementById('grid-gainers').innerHTML = '<div class="msg">---</div>';
        document.getElementById('grid-volume').innerHTML = '<div class="msg">---</div>';
        return;
      }

      try {
        await loadTrendingTop5(fromManualRefresh);
      } catch (e) {
        console.warn('[trend] fetch failed', e);
        SECTION_ERRORS.trend = true;
        trendingCoins = [];
      }

      setUpdated();
      // 完了時のメッセージ
      if (!IN_AUTO_REFRESH) setStatus(fromManualRefresh ? '更新完了' : (SECTION_ERRORS.trend ? '同期完了（一部待機）' : '最新'));
      
      renderAll();
      HAS_RENDERED_ONCE = true;
      markRefreshed();

    } catch(e){
      console.error('init failed:', e);
      setStatus('ネットワーク混雑中');

      // 初回ロード時だけ「---」に置き換える（更新時は直前の表示を維持してチラつきを防ぐ）
      if (firstLoad){
        document.getElementById('grid-trend').innerHTML = '<div class="msg">データの取得が一時的に不安定です。時間をおいて再読み込みしてください。</div>';
        document.getElementById('grid-gainers').innerHTML = '<div class="msg">---</div>';
        document.getElementById('grid-volume').innerHTML = '<div class="msg">---</div>';
        document.getElementById('grid-mcap').innerHTML = '<div class="msg">---</div>';
      }
    } finally {
      if (!firstLoad) setRefreshingAll(false);
    }
  }

  // 初回ロード

  // --- Market Overview: detail toggle (charts on/off) ---
  function setupOverviewToggle(){
    const btn = document.getElementById('btnOverviewToggle');
    const wrap = document.getElementById('overviewWrap');
    if (!btn || !wrap) return;

    const KEY = 'cr_overview_detail_open_v1';

    const apply = (open, rerender=false) => {
      if (open){
        wrap.classList.remove('is-collapsed');
        btn.textContent = '閉じる';
        btn.setAttribute('aria-expanded','true');
      } else {
        wrap.classList.add('is-collapsed');
        btn.textContent = '詳細';
        btn.setAttribute('aria-expanded','false');
      }
      try{ syncHeaderHeight(); }catch(_e){}
      if (open && rerender){
        setTimeout(() => { try{ renderOverview(); }catch(_e){} }, 30);
      }
    };

    const stored = localStorage.getItem(KEY);
    let open = (stored === null) ? (window.innerWidth >= 980) : (stored === '1');
    apply(open, true);

    btn.addEventListener('click', () => {
      open = !open;
      localStorage.setItem(KEY, open ? '1' : '0');
      apply(open, true);
    });

    window.__setOverviewOpen = (v) => {
      open = !!v;
      localStorage.setItem(KEY, open ? '1' : '0');
      apply(open, true);
    };
  }
  // 初回ロード
  (function boot(){
    try{ syncHeaderHeight(); setupOverviewToggle(); setupSideMenu(); }catch(_e){}
    tickRefreshButton();
    init(false);
    try{ startUpdatedTicker(); }catch(_e){}
    try{ startAutoRefresh(); }catch(_e){}
  })();
;
</script>
<div class="info-modal-overlay" id="pageModalOverlay" onclick="closePageModal()">
  <div class="info-modal" onclick="event.stopPropagation()">
    <div class="info-header">
      <div class="info-title" id="pageModalTitle">タイトル</div>
      <button class="info-close" onclick="closePageModal()">×</button>
    </div>
    <div class="info-body" id="pageModalBody">
      <div style="text-align:center; padding:40px; color:#94a3b8;">
        読み込み中...
      </div>
    </div>
  </div>
</div>
<script>
  // ▼▼▼ 外部HTML読み込みスクリプト ▼▼▼
  
  async function openPageModal(url, title) {
    const overlay = document.getElementById('pageModalOverlay');
    const titleEl = document.getElementById('pageModalTitle');
    const bodyEl = document.getElementById('pageModalBody');
    
    // 1. モーダルを開く（まずは「読み込み中」を表示）
    titleEl.textContent = title;
    bodyEl.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100%;color:#94a3b8;">読み込み中...</div>';
    overlay.classList.add('open');

    // サイドメニューが開いていれば閉じる
    const menu = document.getElementById('sideMenu');
    const menuOverlay = document.getElementById('sideMenuOverlay');
    if(menu) menu.classList.remove('is-open');
    if(menuOverlay) menuOverlay.hidden = true;

    try {
      // 2. ファイルを取得 (Fetch)
      // キャッシュを防ぐために ?v=... をつけるのがコツです
      const res = await fetch(url + '?v=' + Date.now());
      
      if (!res.ok) {
        throw new Error('ページが見つかりませんでした (' + res.status + ')');
      }

      // 3. テキストとして取得
      const text = await res.text();

      // 4. HTMLから <body> の中身だけを簡易的に抽出する（フルHTMLの場合）
      // ※もし start.html がパーツのみなら text そのままでOK
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, 'text/html');
      
      // bodyがあればその中身、なければ全体を表示
      const content = doc.body ? doc.body.innerHTML : text;
      
      bodyEl.innerHTML = content;

    } catch (e) {
      console.error(e);
      bodyEl.innerHTML = `<div style="padding:20px;text-align:center;color:#f87171;">
        読み込みに失敗しました。<br><br>
        <small>${e.message}</small>
      </div>`;
    }
  }

  function closePageModal() {
    document.getElementById('pageModalOverlay').classList.remove('open');
  }
// ▼▼▼ 修正版：daily_post_short.txt と同じフォーマットでシェアする関数 ▼▼▼
function shareMarketStatus() {
  // 0. 日付情報の取得 (JST)
  const now = new Date();
  const mm = String(now.getMonth() + 1).padStart(2, '0');
  const dd = String(now.getDate()).padStart(2, '0');
  const yyyy = now.getFullYear();
  const dateLabel = `${mm}/${dd}`;
  const fileDate = `${yyyy}${mm}${dd}`;

  // 1. BTC情報の取得
  const btc = marketsTop.find(c => c.id === 'bitcoin');
  if (!btc) return;

  const chg = btc.price_change_percentage_24h || 0;
  // Python版と同じ分析ロジック
  const aiStatusMsg = chg > 3 ? "分析: 楽観" : (chg < -3 ? "分析: 悲観" : "分析: 中立");
  const icon = chg > 0 ? '📈' : '📉';
  const sign = chg > 0 ? '+' : '';

  // 各種指標を画面上の要素から直接取得（一貫性を保つため）
  const rsiVal = document.getElementById('sumRsiMain')?.textContent || '-';
  const fgiVal = document.getElementById('sumSentMain')?.textContent || '-';
  const fgiLabel = document.getElementById('sumSentSub')?.textContent || '';

  // 2. 注目銘柄の取得
  const trendNames = trendingCoins.slice(0, 3).map(c => c.symbol.toUpperCase());
  const trendingStr = trendNames.length ? trendNames.join(', ') : '-';

  const gainers = getGainersTop5();
  const topGainer = gainers.length ? gainers[0] : null;
  let gainerText = '-';
  if (topGainer) {
    const gSym = topGainer.symbol.toUpperCase();
    const gPct = Math.round(topGainer.price_change_percentage_24h);
    gainerText = `${gSym} (${gPct}%↑)`;
  }

  // 3. テキストの組み立て (daily_post_short.txt の最新フォーマットに完全準拠)
  const text = [
    `🤖 CoinRader 市場速報 (${dateLabel})\n`,
    `${aiStatusMsg}\n\n`,
    `🔹 Bitcoin ${icon}\n`,
    `価格: ${yenLarge(btc.current_price)}\n`, // yenLargeで「¥1357万」形式にする
    `前日比: ${sign}${chg.toFixed(1)}%\n`,
    `RSI(14): ${rsiVal}\n`,
    `心理指数: ${fgiVal} (${fgiLabel})\n\n`,
    `📈 注目銘柄\n`,
    `トレンド入り: ${trendingStr}\n`,
    `急上昇銘柄: ${gainerText}\n\n`,
    `📊 詳細分析\n`,
    `https://coinrader.net/share/${fileDate}.html\n\n`, // 日別URLを動的に生成
    `#CoinRader #ビットコイン #暗号資産`
  ].join('');

  // 4. Xの投稿画面をポップアップウィンドウで開く
  const width = 600;
  const height = 400;
  const left = (window.innerWidth - width) / 2;
  const top = (window.innerHeight - height) / 2;
  
  const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
  
  // '_blank' の代わりにウィンドウのサイズと位置を指定
  window.open(
    url, 
    'share_window', 
    `width=${width},height=${height},left=${left},top=${top},scrollbars=yes,resizable=yes`
  );
  
  // アナリティクス計測
  if(typeof fireCtaClick === 'function'){
    fireCtaClick({cta_id:'share_x', placement:'overview', partner:'self', pr:0});
  }
}
</script>
</body>
</html>
